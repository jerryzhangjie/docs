(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{429:function(e,n,t){"use strict";t.r(n);var o=t(44),s=Object(o.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("web 开发中，经常遇到需要实时刷新数据的场景，例如即时聊天、新闻推送、数据监控等。\n目前常用的实现方式共 5 种：")]),e._v(" "),t("h2",{attrs:{id:"_1-短轮询-polling"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-短轮询-polling"}},[e._v("#")]),e._v(" 1. 短轮询(Polling)")]),e._v(" "),t("p",[e._v("短轮询实现原理是，客户端设置定时器，每隔一定时间向服务端发送 http 请求，服务端收到请求后，不管是否有新数据，都进行响应，响应完成后即关闭本次 TCP 连接。客户端代码实现：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("    setInterval(() => {\n        fetch(url).then((res) => {\n            // do something\n        })\n    }, 5000)\n")])])]),t("h2",{attrs:{id:"_2-长轮询-long-polling"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-长轮询-long-polling"}},[e._v("#")]),e._v(" 2. 长轮询(Long-Polling)")]),e._v(" "),t("p",[e._v("长轮询实现原理是，客户端发送 http 请求，服务端收到请求后，判断是否有新数据：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("若有，则进行响应，客户端收到响应后，渲染数据并发起新的请求；")])]),e._v(" "),t("li",[t("p",[e._v("若无，则服务端 hold 连接，将请求挂起，请求处于 pending 状态，直到有数据或者超时才返回。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  refreshData() {\n      fetch(url).then((res) => {\n          // do something\n          refreshData()\n      }).catch((error) => {\n          // do something\n          refreshData()\n      })\n  }\n")])])])])]),e._v(" "),t("h2",{attrs:{id:"_3-长连接-iframe"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-长连接-iframe"}},[e._v("#")]),e._v(" 3. 长连接(iframe)")]),e._v(" "),t("p",[e._v("长连接实现原理是，在页面中插入一个隐藏的 iframe 标签，利用 iframe 的 src 属性在客户端与服务端之间建立一个长连接，服务端向 iframe 传输数据(通常是"),t("code",[e._v("<script>")]),e._v("标签包裹的 js 代码，动态将有效数据插入页面或更新页面)。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('    // 前端\n    <div id="refresh_wrap"></div>\n    <iframe src="/get-refresh-data" style="display: none;"></iframe>\n\n    // 后端\n    if (hasRefreshData) {\n        res.write(`\n            <script type="text/javascript">\n                parent.document.getElementById(\'refresh_wrap\').innerHTML = "${data}";  // 改变父窗口dom元素\n            <\/script>\n        `)\n    }\n')])])]),t("h2",{attrs:{id:"_4-服务端推送事件-sse-server-sent-event"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-服务端推送事件-sse-server-sent-event"}},[e._v("#")]),e._v(" 4. 服务端推送事件(SSE, Server Sent Event)")]),e._v(" "),t("p",[e._v("严格来说，HTTP 协议是无法实现服务端推送的，但是当服务端向客户端声明接下来发送的是流信息时，连接将处于打开状态，SSE正是利用这一特性实现了服务端推送。"),t("br"),e._v("\nSSE在某写场景下可作为 WebSocket 的替代方案，二者对比如下：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("SSE 是单向通道，仅能从服务端向客户端发送信息；")])]),e._v(" "),t("li",[t("p",[e._v("SSE 的实现成本更低，尤其是服务端；")])]),e._v(" "),t("li",[t("p",[e._v("SSE 不需要单独部署一套服务，而 WebSocket 需要单独部署；")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  // 前端\n  if (window.EventSource) {\n      const source = new EventSource('/xxx/xxx')   // 创建 EventSource 对象并连接服务器\n\n      // 连接成功后触发 open 事件\n      source.addEventListener('open', () => {\n          console.log('Connected');\n      }, false);\n\n      // 服务器发送信息到客户端时，如果没有 event 字段，默认会触发 message 事件\n      source.addEventListener('message', e => {\n          console.log(`data: ${e.data}`);\n      }, false);\n\n      // 自定义 EventHandler，在收到 event 字段为 slide 的消息时触发\n      source.addEventListener('slide', e => {\n          console.log(`data: ${e.data}`); // => data: 7\n      }, false);\n\n      // 连接异常时会触发 error 事件并自动重连\n      source.addEventListener('error', e => {\n          if (e.target.readyState === EventSource.CLOSED) {\n          console.log('Disconnected');\n          } else if (e.target.readyState === EventSource.CONNECTING) {\n          console.log('Connecting...');\n          }\n      }, false);\n  }\n\n  // 服务端\n  const http = require('http');\n\n  http.createServer((req, res) => {\n\n  // 服务器声明接下来发送的是事件流\n  res.writeHead(200, {\n      'Content-Type': 'text/event-stream',\n      'Cache-Control': 'no-cache',\n      'Connection': 'keep-alive',\n      'Access-Control-Allow-Origin': '*',\n  });\n\n  // 发送消息\n  setInterval(() => {\n      res.write('event: slide\\n'); // 事件类型\n      res.write(`id: ${+new Date()}\\n`); // 消息 ID\n      res.write('data: 7\\n'); // 消息数据\n      res.write('retry: 10000\\n'); // 重连时间\n      res.write('\\n\\n'); // 消息结束\n  }, 3000);\n\n  // 发送注释保持长连接\n  setInterval(() => {\n      res.write(': \\n\\n');\n  }, 12000);\n  }).listen(2000);\n")])])])])]),e._v(" "),t("h2",{attrs:{id:"_5-websocket"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-websocket"}},[e._v("#")]),e._v(" 5. WebSocket")]),e._v(" "),t("h3",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[e._v("#")]),e._v(" 简介")]),e._v(" "),t("p",[e._v("与"),t("code",[e._v("http/https")]),e._v("协议仅能由客户端发起请求不同，"),t("code",[e._v("WebSocket")]),e._v("既可以由客户端发起请求，也可以实现服务端主动向客户端推送信息，是一种真正的全双工通信协议。主要特点：")]),e._v(" "),t("ul",[t("li",[e._v("与"),t("code",[e._v("http/https")]),e._v("一样，建立在"),t("code",[e._v("TCP")]),e._v("之上，服务端容易实现。")]),e._v(" "),t("li",[e._v("与"),t("code",[e._v("http/https")]),e._v("兼容良好，默认端口也是"),t("code",[e._v("80/443")]),e._v("，因此握手阶段采用"),t("code",[e._v("http/https")]),e._v("实现连接。")]),e._v(" "),t("li",[e._v("无同源限制，可与任何服务端通信，可取代 ajax。")]),e._v(" "),t("li",[e._v("协议标识符为"),t("code",[e._v("ws/wss")]),e._v("(对应"),t("code",[e._v("http/https")]),e._v(")，因此请求地址形如:"),t("code",[e._v("ws://example.com:80/some/path")]),e._v("。")])]),e._v(" "),t("h3",{attrs:{id:"原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[e._v("#")]),e._v(" 原理")]),e._v(" "),t("p",[e._v("如上所述，客户端发起"),t("code",[e._v("WebSocket")]),e._v("连接请求，其握手阶段采用"),t("code",[e._v("http/https")]),e._v("实现连接，但请求头与一般"),t("code",[e._v("http/https")]),e._v("有所不同，类似下面这样：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("    GET / HTTP/1.1\n    Connection: Upgrade\n    Upgrade: websocket\n    Host: example.com\n    Origin: null\n    Sec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==\n    Sec-WebSocket-Version: 13\n")])])]),t("ul",[t("li",[t("code",[e._v("Connection")]),e._v("通知服务端，如果支持升级的话，进行协议升级。")]),e._v(" "),t("li",[t("code",[e._v("Upgrade")]),e._v("通知服务端，将协议由"),t("code",[e._v("HTTP/1.1")]),e._v("升级到"),t("code",[e._v("WebSocket")]),e._v("。")]),e._v(" "),t("li",[t("code",[e._v("Origin")]),e._v("提供请求发出的域名，供服务端权限校验(服务端也可不校验)。")]),e._v(" "),t("li",[t("code",[e._v("Sec-WebSocket-Key")]),e._v("提供握手协议的密钥，是 Base64 编码的 16 字节随机字符串。")])]),e._v(" "),t("p",[e._v("服务端的"),t("code",[e._v("WebSocket")]),e._v("响应类似如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("    HTTP/1.1 101 Switching Protocols\n    Connection: Upgrade\n    Upgrade: websocket\n    Sec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=\n    Sec-WebSocket-Origin: null\n    Sec-WebSocket-Location: ws://example.com/\n")])])]),t("ul",[t("li",[t("code",[e._v("Connection")]),e._v("通知客户端，如果支持升级的话，进行协议升级。")]),e._v(" "),t("li",[t("code",[e._v("Upgrade")]),e._v("通知客户端，将协议由"),t("code",[e._v("HTTP/1.1")]),e._v("升级到"),t("code",[e._v("WebSocket")]),e._v("。")]),e._v(" "),t("li",[t("code",[e._v("Sec-WebSocket-Accept")]),e._v("提供握手协议的密钥，它是在"),t("code",[e._v("Sec-WebSocket-Key")]),e._v("后边拼接特定字符串后生成的字符串，以便客户端校验是否是目标服务端响应了请求。")]),e._v(" "),t("li",[t("code",[e._v("Sec-WebSocket-Location")]),e._v("提供进行通信的"),t("code",[e._v("WebSocket")]),e._v("地址。")])]),e._v(" "),t("p",[e._v("完成握手以后，"),t("code",[e._v("WebSocket")]),e._v("协议就在 "),t("code",[e._v("TCP")]),e._v(" 协议之上建立了连接，开始传送数据。")]),e._v(" "),t("h3",{attrs:{id:"应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#应用"}},[e._v("#")]),e._v(" 应用")]),e._v(" "),t("p",[t("strong",[e._v("客户端示例")])]),e._v(" "),t("p",[e._v("客户端使用"),t("code",[e._v("WebSocket")]),e._v("无非进行如下操作：")]),e._v(" "),t("ul",[t("li",[e._v("建立连接和断开连接")]),e._v(" "),t("li",[e._v("发送数据和接收数据")]),e._v(" "),t("li",[e._v("处理错误")])]),e._v(" "),t("p",[e._v("代码示例：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("    // 通过`http/https`握手，建立连接\n    var ws = new WebSocket('wss://echo.websocket.org');\n\n    // 连接成功后的回调\n    ws.onopen = function(evt) {\n        console.log('Connection open ...');\n        // 向服务端发送数据\n        ws.send('Hello WebSockets!');\n    };\n\n    // 收到服务端数据后的回调\n    ws.onmessage = function(evt) {\n        console.log('Received Message: ' + evt.data);\n        // 断开连接\n        ws.close();\n    };\n\n    // 连接断开后的回调\n    ws.onclose = function(evt) {\n        console.log('Connection closed.');\n    };\n\n    // 报错时的回调\n    ws.onerror = function(event) {\n        console.log('')\n    };\n")])])]),t("p",[t("strong",[e._v("服务端")])]),e._v(" "),t("p",[t("code",[e._v("WebSocket")]),e._v(" 协议需要服务器支持。常用的 "),t("code",[e._v("Node")]),e._v(" 实现有以下三种:")]),e._v(" "),t("ul",[t("li",[e._v("µWebSockets")]),e._v(" "),t("li",[e._v("Socket.IO")]),e._v(" "),t("li",[e._v("WebSocket-Node")])])])}),[],!1,null,null,null);n.default=s.exports}}]);