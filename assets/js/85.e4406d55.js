(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{439:function(t,v,a){"use strict";a.r(v);var _=a(44),e=Object(_.a)({},(function(){var t=this,v=t.$createElement,a=t._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("开源与跨平台的 JavaScript 运行时环境")]),t._v(" "),a("p",[t._v("运行于单个进程中，无需为每个请求创建新的线程")]),t._v(" "),a("p",[t._v("异步I/O、非阻塞。执行 I/O 操作时（例如从网络读取、访问数据库或文件系统），Node.js 会在响应返回时恢复操作，而不是阻塞线程并浪费 CPU 循环等待。——> 高并发")]),t._v(" "),a("h2",{attrs:{id:"什么是-node-js"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是-node-js"}},[t._v("#")]),t._v(" 什么是 Node.js")]),t._v(" "),a("h3",{attrs:{id:"官方定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#官方定义"}},[t._v("#")]),t._v(" 官方定义")]),t._v(" "),a("ul",[a("li",[t._v("Node.js 是一个基于 "),a("strong",[t._v("Chrome V8 引擎")]),t._v("的 JavaScript 运行环境。")]),t._v(" "),a("li",[t._v("Node.js 使用了一个"),a("strong",[t._v("事件驱动")]),t._v("、"),a("strong",[t._v("非阻式I/O")]),t._v(" 的模型，使其轻量且高效。")])]),t._v(" "),a("h3",{attrs:{id:"node-js-中与-chrome-中写-js-有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#node-js-中与-chrome-中写-js-有什么区别"}},[t._v("#")]),t._v(" Node.js 中与 Chrome 中写 JS 有什么区别")]),t._v(" "),a("ul",[a("li",[t._v("Node.js 没有浏览器 API，即 document、window 等")]),t._v(" "),a("li",[t._v("加入了许多 Node.js API")]),t._v(" "),a("li",[t._v("Chrome 中写 JS 控制浏览器，Node.js 中写 JS 控制整个计算机")])]),t._v(" "),a("h2",{attrs:{id:"node-js-好在哪"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#node-js-好在哪"}},[t._v("#")]),t._v(" Node.js 好在哪")]),t._v(" "),a("h3",{attrs:{id:"在处理高并发、i-o-密集场景性能优势明显"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#在处理高并发、i-o-密集场景性能优势明显"}},[t._v("#")]),t._v(" 在处理高并发、I/O 密集场景性能优势明显")]),t._v(" "),a("p",[t._v("CPU 密集：压缩、解压、加密、解密、运算")]),t._v(" "),a("p",[t._v("I/O 密集：文件操作、网络操作、数据库读写")]),t._v(" "),a("p",[t._v("web 常见场景：")]),t._v(" "),a("ul",[a("li",[t._v("静态资源读取")]),t._v(" "),a("li",[t._v("数据库操作")]),t._v(" "),a("li",[t._v("渲染页面")])]),t._v(" "),a("p",[t._v("高并发应对之道：")]),t._v(" "),a("ul",[a("li",[t._v("增加机器数")]),t._v(" "),a("li",[t._v("增加每台机器的 CPU 数 —— 多核")])]),t._v(" "),a("p",[t._v("Node.js 的单线程")]),t._v(" "),a("ul",[a("li",[t._v("单线程只是针对主进程，操作系统底层的多线程调度来完成 I/O")]),t._v(" "),a("li",[t._v("单线程并不是单进程")])]),t._v(" "),a("h2",{attrs:{id:"node-js-可以用来做什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#node-js-可以用来做什么"}},[t._v("#")]),t._v(" Node.js 可以用来做什么")]),t._v(" "),a("h3",{attrs:{id:"现阶段应用领域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#现阶段应用领域"}},[t._v("#")]),t._v(" 现阶段应用领域")]),t._v(" "),a("ul",[a("li",[t._v("web 服务中间层 - web server")]),t._v(" "),a("li",[t._v("构建工作流 - 本地代码构建（属于cpu密集，从性能考虑并不适合node来做，但因为前端熟悉js）")]),t._v(" "),a("li",[t._v("实用小工具开发 - 脚本工具、爬虫等")]),t._v(" "),a("li",[t._v("客户端应用")])]),t._v(" "),a("h3",{attrs:{id:"web-服务中间层"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#web-服务中间层"}},[t._v("#")]),t._v(" web 服务中间层")]),t._v(" "),a("h5",{attrs:{id:"实例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实例"}},[t._v("#")]),t._v(" 实例")]),t._v(" "),a("p",[t._v("腾讯视频")]),t._v(" "),a("h5",{attrs:{id:"原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原因"}},[t._v("#")]),t._v(" 原因")]),t._v(" "),a("ol",[a("li",[t._v("搜索引擎优化 + 首屏加速 = 服务端渲染")]),t._v(" "),a("li",[t._v("服务端渲染 + 前后端同构 = Node.js")])]),t._v(" "),a("h3",{attrs:{id:"构建工作流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#构建工作流"}},[t._v("#")]),t._v(" 构建工作流")]),t._v(" "),a("h5",{attrs:{id:"实例-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实例-2"}},[t._v("#")]),t._v(" 实例")]),t._v(" "),a("ol",[a("li",[t._v("gulp")]),t._v(" "),a("li",[t._v("webpack")])]),t._v(" "),a("h5",{attrs:{id:"原因-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原因-2"}},[t._v("#")]),t._v(" 原因")]),t._v(" "),a("ol",[a("li",[t._v("前端构建工具是为了构建前端代码 = 使用对象是前端开发")]),t._v(" "),a("li",[t._v("功能需要扩展、问题需要修复 = 前端开发看得懂、能解决 = Node.js")])]),t._v(" "),a("h3",{attrs:{id:"客户端应用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#客户端应用"}},[t._v("#")]),t._v(" 客户端应用")]),t._v(" "),a("h5",{attrs:{id:"实例-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实例-3"}},[t._v("#")]),t._v(" 实例")]),t._v(" "),a("ol",[a("li",[t._v("VS Code")]),t._v(" "),a("li",[t._v("游戏 - wayward")])]),t._v(" "),a("h5",{attrs:{id:"原因-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原因-3"}},[t._v("#")]),t._v(" 原因")]),t._v(" "),a("p",[t._v("​\t使用 Node.js 的客户端技术 Electron")]),t._v(" "),a("h2",{attrs:{id:"安装-3m安装法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#安装-3m安装法"}},[t._v("#")]),t._v(" 安装（3m安装法）")]),t._v(" "),a("h3",{attrs:{id:"nvm-node-版本安装及管理工具"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nvm-node-版本安装及管理工具"}},[t._v("#")]),t._v(" nvm( node 版本安装及管理工具 )")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("安装 nvm")]),t._v(" "),a("p",[a("code",[t._v("curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.1/install.sh | bash")])])]),t._v(" "),a("li",[a("p",[t._v("查看可安装node版本")]),t._v(" "),a("p",[a("code",[t._v("nvm ls-remote")])])]),t._v(" "),a("li",[a("p",[t._v("安装node")]),t._v(" "),a("p",[a("code",[t._v("nvm install 14.15.1")])]),t._v(" "),a("p",[a("code",[t._v("nvm install 8")])])]),t._v(" "),a("li",[a("p",[t._v("查看本机已安装版本")]),t._v(" "),a("p",[a("code",[t._v("nvm ls")])])]),t._v(" "),a("li",[a("p",[t._v("切换版本")]),t._v(" "),a("p",[a("code",[t._v("nvm use 14.15.1")])])]),t._v(" "),a("li",[a("p",[t._v("指定默认版本")]),t._v(" "),a("p",[t._v("切换到目标版本后\t"),a("code",[t._v("nvm alias default node")])])]),t._v(" "),a("li",[a("p",[t._v("重新安装全局模块")]),t._v(" "),a("p",[t._v("通过某个版本node自带的npm安装的全局模块，仅能在当前版本node环境使用，若要使node v14.15.1上安装的全局模块在其它node版本中共用，可执行")]),t._v(" "),a("p",[a("code",[t._v("nvm reinstall-packages 14.15.1")])])])]),t._v(" "),a("h3",{attrs:{id:"npm-nodejs-包下载工具"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#npm-nodejs-包下载工具"}},[t._v("#")]),t._v(" npm( nodejs 包下载工具)")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("安装npm")]),t._v(" "),a("p",[t._v("因为npm本身也是一个Node.js模块，所以可以通过 npm 来安装")]),t._v(" "),a("p",[a("code",[t._v("npm install -g npm@2.9")])])]),t._v(" "),a("li",[a("p",[t._v("常用选项")]),t._v(" "),a("p",[a("code",[t._v("无选项")]),t._v("\t安装到 node_module ，但不保存到 package.json")]),t._v(" "),a("p",[a("code",[t._v("--global/-g")]),t._v("\t安装到全局，如果是命令行模块，会直接链接到环境变量里")]),t._v(" "),a("p",[a("code",[t._v("--save/-S")]),t._v("\t安装 node_module ，并保存在 package.json 里的 dependencies ，表示生产环境依赖的模块")]),t._v(" "),a("p",[a("code",[t._v("--save-dev/-D")]),t._v("\t安装 node_module ，并保存在 package.json 里的 devDependencies ，表示开发环境依赖的模块")])])]),t._v(" "),a("h3",{attrs:{id:"nrm-npm-镜像源切换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nrm-npm-镜像源切换"}},[t._v("#")]),t._v(" nrm( npm 镜像源切换)")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("安装")]),t._v(" "),a("p",[a("code",[t._v("npm install -g nrm")]),t._v("\t因为是命令行模块，所以需要全局安装")])]),t._v(" "),a("li",[a("p",[t._v("查看源")]),t._v(" "),a("p",[a("code",[t._v("nrm ls")]),t._v("\tnpm、cnpm、yarn、taobao等")])]),t._v(" "),a("li",[a("p",[t._v("测速")]),t._v(" "),a("p",[a("code",[t._v("nrm test")])])]),t._v(" "),a("li",[a("p",[t._v("切换源")]),t._v(" "),a("p",[a("code",[t._v("nrm use cnpm")])])]),t._v(" "),a("li",[a("p",[t._v("增加源")]),t._v(" "),a("p",[t._v("为了保证开发效率，企业在内网部署一套私有 npm 源是非常有必要的。推荐使用 cnpm 部署私有源镜像服务器。")]),t._v(" "),a("p",[a("code",[t._v("nrm add 自定义指令名 企业镜像地址")])])])]),t._v(" "),a("h2",{attrs:{id:"node-js-基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#node-js-基础"}},[t._v("#")]),t._v(" Node.js 基础")]),t._v(" "),a("h3",{attrs:{id:"什么是技术预研"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是技术预研"}},[t._v("#")]),t._v(" 什么是技术预研")]),t._v(" "),a("ul",[a("li",[t._v("分析要做的需求，找出技术难点")]),t._v(" "),a("li",[t._v("针对每个技术难点进行攻克")])]),t._v(" "),a("h3",{attrs:{id:"bff-层"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bff-层"}},[t._v("#")]),t._v(" BFF 层")]),t._v(" "),a("blockquote",[a("p",[t._v("即 Backend For Frondend，就是前端和服务端之间的中间渲染层")])]),t._v(" "),a("ul",[a("li",[t._v("对用户侧提供 HTTP 服务")]),t._v(" "),a("li",[t._v("使用后端 RPC(Romote Procedure Call远程过程调用) 服务")])]),t._v(" "),a("h3",{attrs:{id:"模块-commonjs-规范"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模块-commonjs-规范"}},[t._v("#")]),t._v(" 模块：CommonJS 规范")]),t._v(" "),a("h5",{attrs:{id:"的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#的问题"}},[t._v("#")]),t._v(" "),a("script"),t._v(" 的问题")]),t._v(" "),a("ul",[a("li",[t._v("脚本变多时，需要手动管理加载顺序")]),t._v(" "),a("li",[t._v("不同脚本之间逻辑调用，需要通过全局变量的方式")]),t._v(" "),a("li",[t._v("没有 html 安放 script 怎么办？例如 nodejs 中就没有 html")])]),t._v(" "),a("h5",{attrs:{id:"commonjs-模块规范"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#commonjs-模块规范"}},[t._v("#")]),t._v(" CommonJS 模块规范")]),t._v(" "),a("ul",[a("li",[t._v("每个文件是一个模块，有自己的作用域")]),t._v(" "),a("li",[t._v("模块内部 module 变量代表模块本身")]),t._v(" "),a("li",[t._v("module.exports 属性代表模块对外接口")])]),t._v(" "),a("p",[t._v("待整理：规范、exports与module.exports、webpack打包出来的文件")]),t._v(" "),a("p",[t._v("exports 是 module.exports 的快捷方式，common.js 中对外暴露的永远都是module.exports，而exports只是它的引用，所以不能直接给exports赋值，因为赋值会修改exports的指向，只能exports.xx = xx 这样挂载的方式使用。")]),t._v(" "),a("h5",{attrs:{id:"require特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#require特性"}},[t._v("#")]),t._v(" require特性")]),t._v(" "),a("ul",[a("li",[t._v("module 被加载时执行，加载后缓存")]),t._v(" "),a("li",[t._v("循环加载时，只输出已执行的部分，还未执行的部分不会输出")])]),t._v(" "),a("h3",{attrs:{id:"global"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#global"}},[t._v("#")]),t._v(" global")]),t._v(" "),a("ul",[a("li",[t._v("commonjs")]),t._v(" "),a("li",[t._v("buffer、process、console")]),t._v(" "),a("li",[t._v("timer")]),t._v(" "),a("li",[t._v("process.nextTick 放入当前事件队列的队尾，setImmediate 放入下一个队列的队首，setTimeout 介于两者之间")])]),t._v(" "),a("h3",{attrs:{id:"path"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#path"}},[t._v("#")]),t._v(" path")]),t._v(" "),a("ul",[a("li",[t._v("__dirname、__filename 总是返回文件的绝对路径")]),t._v(" "),a("li",[t._v("process.cwd() 总是返回执行 node 命令所在的文件夹")])]),t._v(" "),a("h3",{attrs:{id:""}},[a("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")]),t._v(" ./")]),t._v(" "),a("ul",[a("li",[t._v("在 require 的参数中总是相对当前文件所在的文件夹")]),t._v(" "),a("li",[t._v("在其它地方和 process.cwd() 一样，相对 node 启动文件夹")])]),t._v(" "),a("h3",{attrs:{id:"buffer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#buffer"}},[t._v("#")]),t._v(" Buffer")]),t._v(" "),a("ul",[a("li",[t._v("用来处理二进制数据流")]),t._v(" "),a("li",[t._v("实例类似整数数组，大小固定，默认16进制表示")]),t._v(" "),a("li",[t._v("利用C++代码在V8堆外分配物理内存")])]),t._v(" "),a("h3",{attrs:{id:"内置模块"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内置模块"}},[t._v("#")]),t._v(" 内置模块")]),t._v(" "),a("p",[t._v("负责nodejs的应用层面到操作系统层面的通信，包括nodejs调用操作系统的能力或者说操作系统通知nodejs的能力。有了内置模块，nodejs就具有了强大的和操作系统交互的能力，从而可以做出服务端应用的能力。")]),t._v(" "),a("blockquote",[a("p",[t._v("TODO: 内置模块运行机制 极客时间《Node.js开发实战》12-Node.js内置模块")])]),t._v(" "),a("h3",{attrs:{id:"异步-非阻塞i-o"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步-非阻塞i-o"}},[t._v("#")]),t._v(" 异步：非阻塞I/O")]),t._v(" "),a("p",[t._v("I/O 即 Input/Output，一个系统的输入和输出")]),t._v(" "),a("p",[t._v("阻塞 I/O 和非阻塞 I/O 的区别就在于"),a("strong",[t._v("系统接收输入再到输出期间，能不能接收其它输入")]),t._v("。")]),t._v(" "),a("p",[t._v("nodejs 线程通过事件循环调度其它 C++ 线程来异步处理任务，实现了整个 nodejs 的非阻塞 I/O。")]),t._v(" "),a("h3",{attrs:{id:"异步-异步编程之-callback"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步-异步编程之-callback"}},[t._v("#")]),t._v(" 异步：异步编程之 callback")]),t._v(" "),a("p",[t._v("回调函数规范：error-first callback，即第一个参数是error，后面的参数才是结果。")]),t._v(" "),a("h5",{attrs:{id:"异步流程控制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步流程控制"}},[t._v("#")]),t._v(" 异步流程控制")]),t._v(" "),a("p",[t._v("常见恶心场景：")]),t._v(" "),a("ol",[a("li",[t._v("回调地狱；")]),t._v(" "),a("li",[t._v("并行执行")])]),t._v(" "),a("h3",{attrs:{id:"事件循环"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件循环"}},[t._v("#")]),t._v(" 事件循环")]),t._v(" "),a("p",[t._v("代码模拟：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const eventloop = {\n\t\tqueue: [],\n\t\t\n\t\tloop() {\n\t\t\t\twhile (this.queue.length) {\n\t\t\t\t\t\tconst callback = this.queue.shift()\n\t\t\t\t\t\tcallback()\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsetTimeout(this.loop.bind(this), 50)\n\t\t},\n\t\t\n\t\tadd(callback) {\n\t\t\t\tthis.queue.push(callback)\n\t\t}\n}\n\neventloop.loop()\n\nsetTimeout(() => {\n\t\teventloop.add(() => {\n\t\t\t\tconsole.log(1)\n\t\t})\n}, 500)\n\nsetTimeout(() => {\n\t\teventloop.add(() => {\n\t\t\t\tconsole.log(2)\n\t\t})\n}, 800)\n")])])]),a("h3",{attrs:{id:"异步-异步编程之promise"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步-异步编程之promise"}},[t._v("#")]),t._v(" 异步：异步编程之Promise")]),t._v(" "),a("p",[t._v("当前的事件循环得不到的结果，但未来的事件循环会给到你结果。")]),t._v(" "),a("p",[t._v("执行 then 和 catch 会返回一个新的 Promise，该 Promise 最终状态根据 then 和 catch 的回调函数的执行结果决定：")]),t._v(" "),a("ul",[a("li",[t._v("如果回调函数最终是 throw，该 Promise 是 rejected 状态")]),t._v(" "),a("li",[t._v("如果回调函数最终是 return，该 Promise 是 resolved 状态")]),t._v(" "),a("li",[t._v("如果回调函数最终 return 了一个 Promise，该 Promise 会和回调函数 return 的 Promise 状态保持一致")])]),t._v(" "),a("h3",{attrs:{id:"异步-异步编程之async-await"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步-异步编程之async-await"}},[t._v("#")]),t._v(" 异步：异步编程之async/await")]),t._v(" "),a("ul",[a("li",[t._v("本质是 Promise 的语法糖")]),t._v(" "),a("li",[t._v("异步编程的终极解决方案 - 以同步的方式写异步\n"),a("ul",[a("li",[t._v("await 关键字可以“暂停” async function 后边代码的执行")]),t._v(" "),a("li",[t._v("await 关键字可以以同步的写法获取 Promise 的执行结果")]),t._v(" "),a("li",[t._v("try-catch 可以获取 await 所得到的错误 - 一个穿越 事件循环而存在的 functio n")])])])]),t._v(" "),a("h2",{attrs:{id:"es6-知识点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#es6-知识点"}},[t._v("#")]),t._v(" ES6+知识点")]),t._v(" "),a("h3",{attrs:{id:"生成器-generator"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生成器-generator"}},[t._v("#")]),t._v(" 生成器 Generator")]),t._v(" "),a("p",[t._v("返回一个迭代器，每个迭代器都有 next 方法，用来获取每次迭代生成的对象")]),t._v(" "),a("p",[t._v("node 模块 co 就是利用了 generator")])])}),[],!1,null,null,null);v.default=e.exports}}]);