(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{405:function(n,e,t){"use strict";t.r(e);var s=t(44),r=Object(s.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("ul",[t("li",[t("a",{attrs:{href:"#%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"}},[n._v("什么是设计模式")])]),n._v(" "),t("li",[t("a",{attrs:{href:"#%E5%88%86%E7%B1%BB"}},[n._v("分类")])]),n._v(" "),t("li",[t("a",{attrs:{href:"#%E4%B8%80%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F"}},[n._v("一、结构型模式")]),n._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F"}},[n._v("外观模式")])]),n._v(" "),t("li",[t("a",{attrs:{href:"#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"}},[n._v("代理模式")])])])]),n._v(" "),t("li",[t("a",{attrs:{href:"#%E4%BA%8C%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"}},[n._v("二、创建型模式")]),n._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"}},[n._v("工厂模式")])]),n._v(" "),t("li",[t("a",{attrs:{href:"#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"}},[n._v("单例模式")])])])]),n._v(" "),t("li",[t("a",{attrs:{href:"#%E4%B8%89%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"}},[n._v("三、行为型模式")]),n._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"}},[n._v("策略模式")])]),n._v(" "),t("li",[t("a",{attrs:{href:"#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"}},[n._v("观察者模式")])]),n._v(" "),t("li",[t("a",{attrs:{href:"#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"}},[n._v("发布订阅模式")])])])])]),n._v(" "),t("h1",{attrs:{id:"什么是设计模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是设计模式"}},[n._v("#")]),n._v(" 什么是设计模式")]),n._v(" "),t("blockquote",[t("p",[n._v("对软件设计开发过程中反复出现的某类问题的通用解决方案。是指导思想和方法论，不是特定的代码。")])]),n._v(" "),t("h1",{attrs:{id:"分类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分类"}},[n._v("#")]),n._v(" 分类")]),n._v(" "),t("ol",[t("li",[t("strong",[n._v("结构型模式")]),n._v("：通过识别系统中组件间的简单关系来简化系统的设计。")]),n._v(" "),t("li",[t("strong",[n._v("创建型模式")]),n._v("：处理对象的创建，根据实际情况使用合适的方式创建对象。")]),n._v(" "),t("li",[t("strong",[n._v("行为型模式")]),n._v("：用于识别对象之间常见的交互模式并加以实现。")])]),n._v(" "),t("h1",{attrs:{id:"一、结构型模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、结构型模式"}},[n._v("#")]),n._v(" 一、结构型模式")]),n._v(" "),t("h2",{attrs:{id:"外观模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#外观模式"}},[n._v("#")]),n._v(" 外观模式")]),n._v(" "),t("p",[t("strong",[n._v("是什么")]),n._v("：通过为子系统中的一组接口提供统一的高层接口，使子系统更容易使用。简而言之外观设计模式就是把多个子系统中复杂逻辑进行抽象，从而提供一个更统一、更简洁、更易用的API。")]),n._v(" "),t("p",[t("strong",[n._v("做什么")]),n._v("：比如JQuery就把复杂的原生DOM操作进行了抽象和封装，并消除了浏览器之间的兼容问题，从而提供了一个更高级更易用的版本。")]),n._v(" "),t("p",[t("strong",[n._v("怎么做")]),n._v("：以封装一个DOM事件绑定/解绑方法为例。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("    function addEvent(element, event, handler) {\n        if (element.addEventListener) {\n            element.addEventListener(event, handler, false)\n        } else if (element.attachEvent) {\n            element.attachEvent('on' + event, handler)\n        } else {\n            element['on' + event] = handler\n        }\n    }\n\n    function removeEvent(element, event, handler) {\n        if (element.removeEventListener) {\n            element.removeEventListener(event, handler, false)\n        } else if (element.attachEvent) {\n            element.detachEvent('on' + event, handler)\n        } else {\n            element['on' + event] = null\n        }\n    }\n")])])]),t("h2",{attrs:{id:"代理模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代理模式"}},[n._v("#")]),n._v(" 代理模式")]),n._v(" "),t("p",[t("strong",[n._v("是什么")]),n._v("：想要访问某个对象，但是调用该对象的代价比较高(耗时、流程复杂等)，可以封装一个代理对象，将对目标对象的调用封装在代理对象中，并对外暴露一个与目标对象相同(或更简单)的调用接口。")]),n._v(" "),t("p",[t("strong",[n._v("做什么")]),n._v("：提高调用性能、简化调用复杂度")]),n._v(" "),t("p",[t("strong",[n._v("怎么做")]),n._v("：以中介债券中数据合并为例，数据合并时，只关心债券代码和报价，如果合并过则缓存下来下次再有相同的代码和报价就直接返回。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("    // 缓存代理\n    function proxyMerge = (function() {\n        const cache = {}    \n        return function(newData) {\n            const cacheData = cache[`${newData.code}_${newData.price}`]\n            if (cacheData) {\n                return cacheData\n            }\n            return merge(newData)   // merge函数需要遍历多个长数组，性能较差\n        }\n    })()\n\n    // 使用\n    console.log(proxyMerge(newData))    // 代理了：console.log(merge(newData))\n")])])]),t("h1",{attrs:{id:"二、创建型模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、创建型模式"}},[n._v("#")]),n._v(" 二、创建型模式")]),n._v(" "),t("h2",{attrs:{id:"工厂模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#工厂模式"}},[n._v("#")]),n._v(" 工厂模式")]),n._v(" "),t("p",[t("strong",[n._v("是什么")]),n._v("：可以看成是一个制造其他对象的对象，制造出的对象也会随着传入工厂对象参数的不同而有所区别。")]),n._v(" "),t("p",[t("strong",[n._v("做什么")]),n._v("：提供一种集中化、统一化的方式创建对象，避免了分散创建对象导致的代码重复、灵活性差的问题。")]),n._v(" "),t("p",[t("strong",[n._v("怎么做")]),n._v("：其实 jquery 的选择器就是工厂模式实现的，我们通过 $('div')、$('.div')、$('#div') 都可以创建一个jquery dom对象。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("    class jQuery {\n        constructor(selector) {\n\n        }\n        html() {\n\n        }\n        append() {\n            \n        }\n    }\n    window.$ = function(selector) {\n        return new jQuery(selectpr)\n    }\n")])])]),t("h2",{attrs:{id:"单例模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单例模式"}},[n._v("#")]),n._v(" 单例模式")]),n._v(" "),t("p",[t("strong",[n._v("是什么")]),n._v("：顾名思义，单例模式中Class的实例个数最多为1。当需要一个对象去贯穿整个系统执行某些任务时，单例模式就派上了用场。而除此之外的场景尽量避免单例模式的使用，因为单例模式会引入全局状态，而一个健康的系统应该避免引入过多的全局状态。")]),n._v(" "),t("p",[t("strong",[n._v("做什么")]),n._v("：全局提示弹窗(全局唯一)、唯一登录浮窗")]),n._v(" "),t("p",[t("strong",[n._v("怎么做")]),n._v("：1. 隐藏Class的构造函数，避免多次实例化; 2. 通过暴露一个 getInstance() 方法来创建/获取唯一实例")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("    // 单例构造器\n    const SingletonFoo = (function() {\n        // 隐藏的 Class 构造函数\n        function Foo() {\n            // 一些业务代码\n        }\n        // 未初始化的单例对象\n        let foo\n        return {\n            // 创建/获取单例对象\n            getInstance: function() {\n                if (!foo) {\n                    foo = new Foo()\n                }\n                return foo\n            }\n        }\n    })()\n\n    // 使用\n    const foo1 = SingletonFoo.getInstance()\n    const foo2 = SingletonFoo.getInstance()\n\n    console.log(foo1 === foo2)  // true\n")])])]),t("h1",{attrs:{id:"三、行为型模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、行为型模式"}},[n._v("#")]),n._v(" 三、行为型模式")]),n._v(" "),t("h2",{attrs:{id:"策略模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#策略模式"}},[n._v("#")]),n._v(" 策略模式")]),n._v(" "),t("p",[t("strong",[n._v("是什么")]),n._v("：定义一系列的算法，把它们一个个封装起来，可以方便扩展，并可以任意组合使用。")]),n._v(" "),t("p",[t("strong",[n._v("做什么")]),n._v("：表单验证")]),n._v(" "),t("p",[t("strong",[n._v("怎么做")]),n._v("：1. 封装不同策略的策略组；2. 通过不同组合来实现策略的 Context。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("    // 表单验证为例\n    // 封装策略组\n    var strategies = {  \n        isEmpty: function (value, errorMsg) {  \n            if (value === '' || value === null) {  \n                return errorMsg;  \n            }  \n        },  \n        isMobile: function (value, errorMsg) { // 手机号码格式  \n            if (!/(^1[3|4|5|7|8][0-9]{9}$)/.test(value)) {  \n                return errorMsg;  \n            }  \n        },  \n        minLength: function (value, length, errorMsg) {  \n            if (value.length < length) {  \n                return errorMsg;  \n            }  \n        }  \n    };\n\n    // 验证 “手机号” 的 Context\n    function validMobile(dom) {\n        let value = dom.value\n        let isEmpty = strategies.isEmpty(value, '手机号不能为空')\n        let isValid = strategies.isMobile(value,'手机号格式错误')\n        let errorMsg = isEmpty||isValid\n        if(errorMsg){  \n            alert(errorMsg); \n            return false;  \n        } \n    }\n")])])]),t("h2",{attrs:{id:"观察者模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#观察者模式"}},[n._v("#")]),n._v(" 观察者模式")]),n._v(" "),t("p",[t("strong",[n._v("是什么")]),n._v("：对象间的一种一对多的依赖关系；当被观察者的状态发生改变时，其他观察者皆会得到通知并自动更新。")]),n._v(" "),t("p",[t("strong",[n._v("做什么")]),n._v("：")]),n._v(" "),t("p",[t("strong",[n._v("怎么做")]),n._v("：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("    // 被观察者 Subject\n    class Subject {\n        constructor() {\n            this.state = 1\n            this.observers = []     // 观察者列表\n        }\n\n        setState(state) {\n            this.state = state  \n            this.notify()\n        }\n\n        add(observer) {\n            this.observers.push(observer)\n        }\n\n        notify() {\n            this.observers.forEach(observer => {\n                observer.update()\n            })\n        }\n    }\n\n    // 观察者 Observer\n    class Observer {\n        constructor(name, subject) {\n            this.name = name\n            this.subject = subject\n            this.subject.add(this)      // 将自己加入观察者列表中\n        }\n\n        update() {\n            console.log(`now, subject state is ${this.subject.state}, so ${this.name} has updated`)\n        }\n    }\n\n    const sub = new Subject()\n    const o1 = new Observer('observer1', sub)\n    const o2 = new Observer('observer2', sub)\n    const o3 = new Observer('observer3', sub)\n\n    sub.setState(2)\n")])])]),t("h2",{attrs:{id:"发布订阅模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#发布订阅模式"}},[n._v("#")]),n._v(" 发布订阅模式")]),n._v(" "),t("p",[t("strong",[n._v("是什么")]),n._v("：发布者发布消息时不会直接把消息发给特定的接收者，而是需要一个中间消息管理器来发送到特定的接收者。所以与观察者模式的区别是：1. 观察者模式只有两个角色 被观察者(发布者) 和 观察者(订阅者)，而发布订阅模式还有一个“中间消息管理器”；2. 观察者模式两个角色间是松耦合，而发布订阅模式两个角色间完全解耦。")]),n._v(" "),t("p",[t("strong",[n._v("做什么")]),n._v("：“事件驱动”项目中，实现组件间通信")]),n._v(" "),t("p",[t("strong",[n._v("怎么做")]),n._v("：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("    class EventBus {        // 中间消息管理器\n        constructor() {\n            this.events = {}\n        }\n\n        on(evt, handler) {  // 订阅\n            this.events[evt] = this.events[evt] || []\n            this.events[evt].push({\n\n            })\n        }\n\n        emit(evt, args) {   // 发布\n            if (!this.events[evt]) return\n            for (let i = 0; i < events[evt].length; i++) {\n                this.events[evt][i]()\n            }\n        }\n\n        off(evt) {          // 取消订阅\n            delete this.events[evt]\n        }\n    }\n\n    // 使用\n    const bus = new EventBus()\n\n    // 订阅\n    bus.on('evt1', function(val) {\n        console.log('emit evt1, val is' + val)\n    })\n    bus.on('evt2', function(val) {\n        console.log('emit evt2, val is' + val)\n    })\n\n    // 发布\n    bus.emit('evt1', '1')\n    bus.emit('evt2', '2')")])])])])}),[],!1,null,null,null);e.default=r.exports}}]);