(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{424:function(o,e,n){"use strict";n.r(e);var v=n(44),t=Object(v.a)({},(function(){var o=this,e=o.$createElement,n=o._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[n("ul",[n("li",[n("p",[o._v("Vue组件无强制命名限制，但组件名终需在html模板中使用，所以必须避免与html保留字重名，官方推荐PascalCase化的命名格式(AbcDef)，例如："),n("code",[o._v("MyComponent")]),o._v("；")])]),o._v(" "),n("li",[n("p",[o._v("Vue 1.0中，对于字符串模板中的组件名，解析过程为：")]),o._v(" "),n("ul",[n("li",[o._v("Vue 会将 template 中的内容插到 DOM 中，以方便解析标签。由于html标签不区分大小写，所有标签名都将转化为小写;")]),o._v(" "),n("li",[o._v("通过标签名寻找对应的自定义组件。匹配顺序为：转化后的小写标签名、camelCase化的标签名、PascalCase化的标签名。")])]),o._v(" "),n("p",[o._v("因此，两种引入形式及其匹配结果如下：")]),o._v(" "),n("ul",[n("li",[o._v("假设模板中"),n("code",[o._v("<MyComponent></MyComponent>")]),o._v("这样引入，首先转为小写"),n("code",[o._v("<mycomponent></mycomponent>")]),o._v("，然后依次匹配"),n("code",[o._v("mycomponent")]),o._v("、"),n("code",[o._v("(无)")]),o._v("、"),n("code",[o._v("Mycomponent")]),o._v("，结果：无法匹配到"),n("code",[o._v("MyComponent")]),o._v("，报错；")]),o._v(" "),n("li",[o._v("假设模板中"),n("code",[o._v("<my-component></my-component>")]),o._v("这样引入，首先转为小写"),n("code",[o._v("<my-component></my-component>")]),o._v("，然后依次匹配"),n("code",[o._v("my-component")]),o._v("、"),n("code",[o._v("myComponent")]),o._v("、"),n("code",[o._v("MyComponent")]),o._v("，结果：匹配到"),n("code",[o._v("MyComponent")]),o._v("，正确解析；")])])]),o._v(" "),n("li",[n("p",[o._v("Vue 2.0 相对于 1.0 的最大改进就是引入了 Virtual DOM，使字符串模板的解析不依赖于 DOM，因此也就无需遵从html的标签规范，字符串模板中两种引入方式"),n("code",[o._v("<MyComponent></MyComponent>")]),o._v("、"),n("code",[o._v("<my-component></my-component>")]),o._v("都是可以的")])])]),o._v(" "),n("p",[o._v("注：Prop也遵守上述规则，但自定义事件名：")]),o._v(" "),n("blockquote",[n("p",[o._v("不会被用作一个 JavaScript 变量名或属性名，v-on 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以 v-on:myEvent 将会变成 v-on:myevent——导致 myEvent 不可能被监听到。\n因此，我们推荐你始终使用 kebab-case 的事件名。")])])])}),[],!1,null,null,null);e.default=t.exports}}]);