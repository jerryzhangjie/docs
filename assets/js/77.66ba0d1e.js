(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{432:function(t,n,e){"use strict";e.r(n);var a=e(44),r=Object(a.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("节流和防抖都是为了解决短时间内多次触发某事件，而造成的性能问题。由于实现原理不同，决定了它们适用于不同的场景。")]),t._v(" "),e("h2",{attrs:{id:"_1-防抖"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-防抖"}},[t._v("#")]),t._v(" 1. 防抖")]),t._v(" "),e("h3",{attrs:{id:"原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[t._v("#")]),t._v(" 原理")]),t._v(" "),e("p",[e("code",[t._v("防抖")]),t._v("是通过维护一个计时器，规定时间结束才会触发事件回调，而规定时间内再次操作时，会清除当前的计时器并重新开始计时，从而保证只有最后一次操作才会被执行。")]),t._v(" "),e("h3",{attrs:{id:"适用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#适用场景"}},[t._v("#")]),t._v(" 适用场景")]),t._v(" "),e("ol",[e("li",[t._v("连续"),e("em",[t._v("输入")]),t._v("，触发 ajax 查询。eg.输入框联想功能")]),t._v(" "),e("li",[t._v("拖动元素或调整窗口大小，触发事件。eg.拖动 div 计算最终放置的坐标位置")])]),t._v(" "),e("p",[t._v("**共性：**无需关注中间环节，仅在意最后那一次的操作所能触发的事件响应。")]),t._v(" "),e("h3",{attrs:{id:"实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[t._v("#")]),t._v(" 实现")]),t._v(" "),e("p",[t._v("以 输入框联想功能 为例：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("    <input type=\"text\" name=\"input\" id=\"input\">\n\n    <script>\n        // 模拟ajax请求\n        function ajax(content) {\n            console.log('ajax request ' + content)\n        }\n\n        // 封装防抖函数\n        function debounce(fun, delay) {\n            let timer = null\n            // 通过闭包避免定义全局变量 timer\n            return function (args) {\n                // 每次触发，都会清除当前的 timer，然后重写开始计时\n                clearTimeout(timer)\n                timer = setTimeout(() => {\n                    fun(args)\n                }, delay)\n            }\n        }\n\n        let input = document.getElementById('input')\n        // 获取防抖回调函数\n        let cbDebounce = debounce(ajax, 500)\n        input.addEventListener('keyup', (e) => {\n            cbDebounce(e.target.value)\n        })\n    <\/script>\n")])])]),e("h2",{attrs:{id:"_2-节流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-节流"}},[t._v("#")]),t._v(" 2. 节流")]),t._v(" "),e("h3",{attrs:{id:"原理-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原理-2"}},[t._v("#")]),t._v(" 原理")]),t._v(" "),e("p",[e("code",[t._v("节流")]),t._v("是保证规定时间范围内，只触发一次事件回调。")]),t._v(" "),e("h3",{attrs:{id:"适用场景-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#适用场景-2"}},[t._v("#")]),t._v(" 适用场景")]),t._v(" "),e("ol",[e("li",[t._v("连续"),e("em",[t._v("滚动")]),t._v("，触发 ajax 查询。eg.滚动加载(实则是数据翻页，每一页数据都不容忽视)")]),t._v(" "),e("li",[t._v("连续点击按钮触发某事件，只在规定时间内触发一次")])]),t._v(" "),e("p",[t._v("**共性：**连续操作中的中间节点不容忽视，需要获取其中每个有效节点的事件响应。")]),t._v(" "),e("h3",{attrs:{id:"实现-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现-2"}},[t._v("#")]),t._v(" 实现")]),t._v(" "),e("p",[t._v("以 列表滚动加载 为例：\n// 模拟ajax请求\nfunction ajax(content) {\nconsole.log('ajax request ' + content)\n}")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("    // 1. 时间戳版（规定时间开始时触发）\n    function throttle(fun, delay) {\n        let preTime = 0     // 上次触发的时间（戳）\n        return function() {\n           let that = this\n           let _args = arguments\n           let now = Date.now()     // 当前时间（戳）\n           if (now - preTime > delay) {\n               preTime = now\n               fun.apply(that, _args)\n           } \n        }\n    }\n\n    // 2. 定时器版（规定时间结束时触发）\n    function throttle(fun, delay) {\n        let timer = null\n        return function() {\n            let that = this\n            let _args = arguments\n            if (!timer) {\n                timer = setTimeout(() => {\n                    timer = null\n                    fun.apply(that, _args)\n                }, delay)\n            }\n        }\n    }\n\n    // 获取节流回调函数\n    let cbThrottle = throttle(ajax, 500)\n    window.addEventListener('scroll', () => {\n        cbThrottle()\n    })\n")])])])])}),[],!1,null,null,null);n.default=r.exports}}]);