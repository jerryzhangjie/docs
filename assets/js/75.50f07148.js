(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{430:function(e,t,a){"use strict";a.r(t);var r=a(44),o=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h3",{attrs:{id:"_1-websocket-可以是非同域名的多个-tab"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-websocket-可以是非同域名的多个-tab"}},[e._v("#")]),e._v(" 1. websocket  (可以是非同域名的多个 tab)")]),e._v(" "),a("p",[e._v("利用 websocket 全双工通信的特性，A tab 页向服务端发送信息，再由服务端向 B tab 页发送信息，即可实现 A 向 B 的通信。")]),e._v(" "),a("h3",{attrs:{id:"_2-localstorage-同域名的多个-tab"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-localstorage-同域名的多个-tab"}},[e._v("#")]),e._v(" 2. localStorage (同域名的多个 tab)")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("localStorage 是浏览器多个标签共用的存储空间，所以可以用来实现多标签之间的通信(ps：sessionStorage 是会话级的存储空间，每个标签页都是单独的）。")])]),e._v(" "),a("li",[a("p",[e._v("直接在window对象上添加监听即可：")]),e._v(" "),a("p",[a("code",[e._v("window.onstorage = (e) => {console.log(e)} // 或者这样 window.addEventListener('storage', (e) => console.log(e))")])])]),e._v(" "),a("li",[a("p",[e._v("onstorage 以及 storage 事件，针对的都是非当前页面对 localStorage 进行修改时才会触发，当前页面修改 localStorage 不会触发监听函数。仅在对已有的数据的值进行修改时才会触发，比如原本已经有一个key为a值为b的 localStorage，你再执行：localStorage.setItem('a', 'b')代码，同样是不会触发监听函数的。")])])]),e._v(" "),a("h3",{attrs:{id:"_3-sharedworker-同域名的多个-tab"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-sharedworker-同域名的多个-tab"}},[e._v("#")]),e._v(" 3. SharedWorker (同域名的多个 tab)")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("SharedWorker 是一个共享"),a("strong",[e._v("进程")]),e._v("中的一个线程，可以被多个tab共同使用，但必须保证这些标签页都是同源的(相同的协议，主机和端口号)。(WebWorker是渲染进程内部的单独"),a("strong",[e._v("线程")]),e._v("，不可多个tab共享)")])]),e._v(" "),a("li",[a("p",[e._v("SharedWorker 的消息传递")]),e._v(" "),a("p",[e._v("// tab 页中\n// 1. 创建 shaerdWorker 对象\nlet worker = new SharedWorker('sharedworkers.js');\n// 传递 start 指令\nworker.port.postMessage('start');\n// 接收子线程的数据\nworker.port.onmessage = function (val) {\ntimeDom.innerHTML = val.data\n}")]),e._v(" "),a("p",[e._v("// sharedworkers.js\nonconnect = function (e) {\n// 通过 e.ports 拿到 port\nvar port = e.ports[0];")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("  // port.onmessage 监听父线程的消息\n  port.onmessage = function () {\n      // port.postMessage 向父线程传递消息\n      port.postMessage(a++)\n  }\n")])])]),a("p",[e._v("}")])])])])}),[],!1,null,null,null);t.default=o.exports}}]);