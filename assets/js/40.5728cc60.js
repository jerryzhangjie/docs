(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{398:function(_,v,t){"use strict";t.r(v);var a=t(44),s=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("p",[_._v("V8 采用的垃圾回收算法 —— 分代回收(Generation GC)")]),_._v(" "),t("h2",{attrs:{id:"一-什么是垃圾"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一-什么是垃圾"}},[_._v("#")]),_._v(" 一. 什么是垃圾")]),_._v(" "),t("p",[_._v("确定不会再被使用的数据，即为垃圾数据。")]),_._v(" "),t("p",[_._v("栈(stack)会自动分配内存空间，会自动释放空间。无需垃圾回收。\n堆(heap)动态分配的内存，大小不定也不会自动释放。需要垃圾回收机制来释放内存空间。\n"),t("strong",[_._v("注")]),_._v("：闭包中的变量并不保存在栈内存中，而是保存在堆内存中。这也是闭包能引用到函数内变量的原因。")]),_._v(" "),t("h2",{attrs:{id:"二、算法分类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、算法分类"}},[_._v("#")]),_._v(" 二、算法分类")]),_._v(" "),t("p",[_._v("常见的 JS 垃圾回收基础算法有两类："),t("strong",[_._v("标记清除")]),_._v("、"),t("strong",[_._v("引用计数")])]),_._v(" "),t("p",[_._v("由于基础算法是对全部对象进行遍历，而JS引擎是单线程的，执行垃圾回收时页面会处在卡顿状态，执行时间越长卡顿现象越久，因此，实际各家浏览器的垃圾回收策略都是在基础算法的基础上做了优化：")]),_._v(" "),t("p",[_._v("V8 的垃圾回收机制：分代回收")]),_._v(" "),t("p",[t("strong",[_._v("分代回收")]),_._v("机制：")]),_._v(" "),t("ol",[t("li",[_._v("将内存分为“新生代区”和“老生代区”，分别存储“新生代对象”和“老生代对象”；")]),_._v(" "),t("li",[_._v("老生代区占用的内存较大，最初存储 JS 原始对象；")]),_._v(" "),t("li",[_._v("新生代区占用的内存较小，且又被分为“活跃区”和“非活跃区”，最初活跃区存放所有新创建的对象，非活跃区为空；")]),_._v(" "),t("li",[_._v("当新生代的活跃区被占满后，将触发垃圾回收，过程如下：")]),_._v(" "),t("li",[_._v("交换新生代的“活跃区”和“非活跃区”")]),_._v(" "),t("li",[_._v("对“非活跃区”的对象进行“标记清除”，过程如下：")])]),_._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[_._v("  * 从根节点开始遍历对象\n  * 未被标记过的活跃对象放回“活跃区”\n  * 已被多次标记的活跃对象放进“老生代区”\n  * 标记出不再活跃的对象，然后统一清除，此时新生代的活跃区只剩下活跃的对象\n")])])]),t("ol",{attrs:{start:"5"}},[t("li",[_._v("当老生代被占满后，触发垃圾回收，“标记清楚”过程如下：")]),_._v(" "),t("li",[_._v("从根节点开始遍历对象")]),_._v(" "),t("li",[_._v("标记出不再活跃的非原始对象(不能清除原始对象)，然后统一清除，此时老生代区只剩下原始对象和活跃的对象")]),_._v(" "),t("li",[_._v("垃圾回收的最后，要进行内存整理，使不连续的内存空间变为连续空间，便于再次使用")])]),_._v(" "),t("h2",{attrs:{id:"三、-标记清除如何回收垃圾"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、-标记清除如何回收垃圾"}},[_._v("#")]),_._v(" 三、 标记清除如何回收垃圾")]),_._v(" "),t("h3",{attrs:{id:"_1-标记"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-标记"}},[_._v("#")]),_._v(" 1. 标记")]),_._v(" "),t("p",[_._v("V8 采用 "),t("strong",[_._v("可达性")]),_._v(" 算法来判断堆中对象应不应该被回收，判断步骤如下：")]),_._v(" "),t("ul",[t("li",[_._v("从根节点出发，遍历所有的对象")]),_._v(" "),t("li",[_._v("可以遍历到的对象，标识为可达(reachable)")]),_._v(" "),t("li",[_._v("无法遍历到的对象，标识为不可达(unreachable)")])]),_._v(" "),t("p",[_._v("浏览器环境下，根节点包括：")]),_._v(" "),t("ul",[t("li",[_._v("全局对象 window，位于每个 iframe 中")]),_._v(" "),t("li",[_._v("文档 DOM 对象")]),_._v(" "),t("li",[_._v("存放在栈中的变量")])]),_._v(" "),t("p",[_._v("根节点不是垃圾，不能被回收。")]),_._v(" "),t("h3",{attrs:{id:"_2-清理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-清理"}},[_._v("#")]),_._v(" 2. 清理")]),_._v(" "),t("p",[_._v("标记完成后，统一清理被标识为不可达的对象。")]),_._v(" "),t("h3",{attrs:{id:"_3-内存整理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-内存整理"}},[_._v("#")]),_._v(" 3. 内存整理")]),_._v(" "),t("p",[_._v("清理操作后，堆内存中存在大量不连续的空间，称为 "),t("strong",[_._v("内存碎片")])]),_._v(" "),t("p",[_._v("https://juejin.im/post/6844903695721709581#heading-15")]),_._v(" "),t("p",[_._v("https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/")]),_._v(" "),t("p",[_._v("https://zhuanlan.zhihu.com/p/33816534")])])}),[],!1,null,null,null);v.default=s.exports}}]);