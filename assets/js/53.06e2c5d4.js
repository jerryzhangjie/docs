(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{409:function(t,n,r){"use strict";r.r(n);var e=r(44),a=Object(e.a)({},(function(){var t=this.$createElement,n=this._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[n("h2",{attrs:{id:"数组排序-专题整理-实现原理、时间复杂度、空间复杂度"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数组排序-专题整理-实现原理、时间复杂度、空间复杂度"}},[this._v("#")]),this._v(" 数组排序（专题整理 实现原理、时间复杂度、空间复杂度）")]),this._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[this._v("let arr = [12, 2, 32, 13, 33, 5, 25]\n\x3c!-- 冒泡排序 --\x3e\n\x3c!-- \n  1.比较相邻的两个元素，如果前一个比后一个大，则交换位置；\n  2.比较完第一轮的时候，最后一个元素是最大的元素，无需参与之后的比较\n --\x3e\nconst len = arr.length - 1 // 假设3个数组，那么只需要2次就能完成排序，所以减1\nfor (let i = 0; i < len; i++) {\n  for (let j = 0; j < len - i; j++) {\n    if (arr[j] > arr[j+1]) {\n      let tem = arr[j]\n      arr[j] = arr[j+1]\n      arr[j+1] = tem\n    }\n  }\n}\n\n\n\x3c!--  --\x3e")])])])])}),[],!1,null,null,null);n.default=a.exports}}]);