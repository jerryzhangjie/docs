(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{420:function(t,n,e){"use strict";e.r(n);var s=e(44),l=Object(s.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("ol",[e("li",[e("p",[t._v("什么是插槽"),e("br"),t._v("\n可以类比电源插排，预先留有插口，符合规格的插头可以插入插口。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 子组件 Child\n<div>\n    <slot>我是个默认插口</slot>\n</div>\n\n// 父组件\n<Child>\n    <p>我是个p标签插头，可以插入默认插口</p>\n</Child>\n")])])])]),t._v(" "),e("li",[e("p",[t._v("具名插槽"),e("br"),t._v("\n默认插口，只能有一个，当需要预留多个插口时，需要给每个插口取个名字（name），这就确定了规格。而每个插头需要用"),e("code",[t._v("v-slot")]),t._v("来实现匹配规格。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('// 子组件 Child\n<div>\n    <slot name="first">\n        我是第一个插口\n    </slot>\n    <slot>\n        我是默认插口\n    </slot>\n    <slot name="last">\n        我是最后一个插口\n    </slot>\n</div>\n\n// 父组件\n<Child>\n    <template v-slot:first>     // v-slot:first 可简写成 #first\n        <p>我是个p标签，我要插入第一个插口中</p>\n    </template>\n\n    <a>我是个a标签，我要插入默认插口中</a>\n\n    <template v-slot:last>\n        <div>我是个div标签，我要插入最后一个插口中</p>\n    </template>\n</Child>\n')])])])]),t._v(" "),e("li",[e("p",[t._v("作用域插槽"),e("br"),t._v("\n适用场景：一个组件，想要实现大部分逻辑共用，只有部分数据模板的展示有区别。"),e("br"),t._v("\n此时存在一个问题，例如有一个列表组件，代码如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('// 列表组件 my-list\n<div>\n    <h3 class="title">{{title}}</h3>\n    <div class="list">\n        <div v-for="item in items">\n            \x3c!-- 列表项 start --\x3e\n            // 此处会用到数据`item`\n            \x3c!-- 列表项 end --\x3e\n        </div>\n    </div>\n</div>\n')])])]),e("p",[e("code",[t._v("my-list")]),t._v("的循环逻辑在组件内，且列表项数据"),e("code",[t._v("item")]),t._v("也是组件内的数据。如果要差异化展示列表项，我们很容易想到利用插槽，将列表模板从父组件中传递进来，但父组件列表模板中如何使用子组件列表项数据"),e("code",[t._v("item")]),t._v("呢？其实，这就是作用域插槽要解决的问题。")]),t._v(" "),e("p",[t._v("要实现作用域插槽，我们需要将"),e("code",[t._v("my-list")]),t._v("进行如下改写：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('// 作用域插槽列表组件 my-list\n<div>\n    <h3 class="title">{{title}}</h3>\n    <div class="list">\n        <div v-for="item in items">\n            \x3c!-- 列表项 start --\x3e\n            // 绑定到插槽上的属性称为`插槽prop`\n            <slot v-bind:item="item">\n                // 若无模板传入时，此处内容为默认展示模板\n                <span>{{item}}</span>\n            </slot>\n            \x3c!-- 列表项 end --\x3e\n        </div>\n    </div>\n</div>\n')])])]),e("p",[t._v("通过在插槽上绑定"),e("code",[t._v("插槽prop")]),t._v("，可以将列表组件插槽中所需要的数据暴露给父组件，以便组装列表项模板。")]),t._v(" "),e("p",[t._v("父组件中调用：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<div>\n    <my-list :title="title" :items="students">\n        // 通过template组装插槽模板，通过v-slot接收所有`插槽prop`\n        <template v-slot="slotProps">\n            <span>{{slotProps.item.name}}</span>\n            <span>{{slotProps.item.age}}</span>\n        </template>\n    </my-list>\n</div>\n')])])]),e("p",[t._v("列表组件中定义好了插槽以及插槽prop，父组件就可以组装待插入的列表项模板了，包括两个关键：1. 通过"),e("code",[t._v("template")]),t._v("组装插槽模板，2. 通过"),e("code",[t._v("v-slot")]),t._v("定义的变量，接收所有"),e("code",[t._v("插槽prop")]),t._v("，以便在插槽模板中使用子组件中的数据。")]),t._v(" "),e("p",[t._v("综上，什么是作用域插槽？")]),t._v(" "),e("blockquote",[e("p",[t._v("为了实现子组件中部分模板的差异化展示，子组件通过"),e("code",[t._v("插槽prop")]),t._v("将差异部分所需数据暴露给父组件，父组件通过"),e("code",[t._v("v-slot")]),t._v("接收暴露出来的数据，并通过"),e("code",[t._v("template")]),t._v("组装差异模板，最终实现父组件控制子组件中部分模板的差异化展示。")])])])])])}),[],!1,null,null,null);n.default=l.exports}}]);