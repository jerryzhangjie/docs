(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{410:function(n,r,t){"use strict";t.r(r);var e=t(44),a=Object(e.a)({},(function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"遇到的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#遇到的"}},[n._v("#")]),n._v(" 遇到的")]),n._v(" "),t("h2",{attrs:{id:"数组排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组排序"}},[n._v("#")]),n._v(" 数组排序")]),n._v(" "),t("p",[n._v("注：假设有大到小")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("    / 冒泡排序\n    // 双循环逐一比较两个元素，交换顺序\n    // 时间复杂度：O(n^2)，空间复杂度：O(1)\n    function sort1(arr) {\n        const len = arr.length\n        for (let i = 0; i < len; i++) {\n            for (let j = i + 1; j < len; j++) {\n                if (arr[j] > arr[i]) {\n                    [arr[i], arr[j]] = [arr[j], arr[i]]\n                }\n            }\n        }\n        return arr\n    }\n    console.log('冒泡排序', sort1([1,3,2,7,5,8,4]))\n\n    // 插入排序\n    // 类比摸扑克牌的过程，新摸到的牌比手中的大则放到前边，新摸到的比手中的小则放到后边\n    // 时间复杂度：O(n^2)，空间复杂度：O(n)\n    function sort2(arr) {\n        let hand = [arr[0]]\n        let arrLen = arr.length\n        for (let i = 1; i < arrLen; i++) {\n            const handLen = hand.length\n            if (arr[i] >= hand[handLen - 1]) {\n                hand.push(arr[i])\n            } else if (arr[i] <= hand[0]) {\n                hand.unshift(arr[i])\n            } else {\n                for (let j = 0; j < handLen - 1; j++) {\n                    if (arr[i] >= hand[j] && arr[i] <= hand[j + 1]) {\n                        hand.splice(j + 1, 0, arr[i])\n                        break\n                    }\n                }\n            }\n        }\n        return hand\n    }\n    console.log('插入排序', sort2([2,1,4,6,8,3,2,4,6,73,2,4,6]))\n\n    // 快速排序\n    // 找到数组中间位置的元素，拿每个元素与中间元素比，大的放左边数组中，小的方右边数组中，针对新数组重复该操作\n    // 时间复杂度：O(n)，空间复杂度：O(n)\n    function sort3(arr) {\n        const len = arr.length\n        if (len <= 1) {\n            return arr\n        }\n        let middle = Math.floor(len/2)\n        let mdlItm = arr[middle-1]\n        arr.splice(middle-1, 1)\n        const leftArr = [], rightArr = []\n        for (let i = 0; i < len -1; i++) {\n            if (arr[i] < mdlItm) {\n                leftArr.push(arr[i])\n            } else {\n                rightArr.push(arr[i])\n            }\n        }\n        return sort3(leftArr).concat(mdlItm, sort3(rightArr))\n    }\n    console.log('快速排序', sort3([3,12,4,6,73,5,6,3,5,72,4]))\n")])])]),t("h2",{attrs:{id:"数组去重"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组去重"}},[n._v("#")]),n._v(" 数组去重")]),n._v(" "),t("ol",[t("li",[t("p",[n._v("Set")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v(" function unique(arr) {\n     return [...new Set(arr)]\n     // return Array.from(new Set(arr))\n }\n")])])])]),n._v(" "),t("li",[t("p",[n._v("indexOf、filter (indexOf获取元素在数组中首次出现的位置，只有唯一的元素其indexOf位置才与遍历时的index相等) O(n)")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v(" function unique(arr) {\n     return arr.filter((item, index, arr) => {\n         return arr.indexOf(item) === index\n     })\n }\n")])])])]),n._v(" "),t("li",[t("p",[n._v("检查是否重复，放入新数组")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v(" // includes检查重复 O(n^2)\n function unique(arr) {\n     let result = []\n     let len = arr.length\n     for (let i = 0; i < len; i++) {\n         let item = arr[i]\n         if (!result.includes(item)) {       // includes内部使用了while循环(其实indexOf也是这样)\n             result.push(item)\n         }\n     }\n     return result\n }\n\n // 对象key值检查重复 O(n)\n function unique(arr) {\n     let obj = {}\n     let result = []\n     let len = arr.length\n     for (let i = 0; i < len; i++) {\n         let item = arr[i]\n         if (!obj[item]) {\n             result.push(item)\n             obj[item] = 1\n         } else {\n             obj[item] += 1\n         }\n     }\n     return result\n }\n // 等价于 reduce 实现 O(n)\n let hash = {}\n function unique(arr, initialVal) {\n     return arr.reduce(function(previousVal, currentVal, index, array) {\n         if (!hash[currentVal]) {\n             previousVal.push(currentVal)\n             hash[currentVal] = 1\n         } else {\n             hash[currentVal] += 1\n         }\n         return previousVal\n     }, initialVal)\n }\n unique(['js', 'css', 'js', 'html'], [])\n")])])])])]),n._v(" "),t("h2",{attrs:{id:"数组扁平化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组扁平化"}},[n._v("#")]),n._v(" 数组扁平化")]),n._v(" "),t("ol",[t("li",[n._v("字符串化")])]),n._v(" "),t("blockquote",[t("p",[n._v("利用数组的 toString 方法(或数组与字符串的隐式转化)，将数组转化为字符串，再用 split 将字符串还原为数组")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("    function flatten(arr) {\n        arr = arr.toString()    // 或者隐式转化   arr += ''\n        return arr.split(',')\n    }\n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[t("p",[n._v("ES6 flat")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v(" function flatten(arr) {\n     return arr.flat(Infinity)\n }\n")])])])]),n._v(" "),t("li",[t("p",[n._v("递归")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v(" // concat\n function flatten(arr) {\n     let result = []\n     let len = arr.length\n     for (let i = 0; i < len; i++) {\n         let item = arr[i]\n         if (Array.isArray(item)) {\n             result = result.concat(flatten(item))\n         } else {\n             result.push(item)\n         }\n     }\n     return result\n }\n\n // reduce、concat\n function flatten(arr) {\n     return arr.reduce((result, curItem) => {\n         curItem = Array.isArray(curItem) ? flatten(curItem) : curItem\n         return result.concat(curItem)\n     }, [])\n }\n\n // 普通递归\n function flatten() {\n     let ret = [];\n     let toArr = function(arr){\n         arr.forEach(function(item){\n             item instanceof Array ? toArr(item) : ret.push(item);\n         });\n     }\n     toArr(arr);\n     return ret;\n }\n")])])])]),n._v(" "),t("li",[t("p",[n._v("结构运算符")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v(" function flatten(arr) {\n     while (arr.some(item => Array.isArray(item))) {\n         arr = [].concat(...arr)\n     }\n     return arr\n }\n")])])])])]),n._v(" "),t("h2",{attrs:{id:"找出数组中第一个不重复的元素"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#找出数组中第一个不重复的元素"}},[n._v("#")]),n._v(" 找出数组中第一个不重复的元素")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("    // 当前元素在去除该元素的数组中是否存在\n    function getFirstUnique(arr) {\n        let len = arr.length\n        let target = ''\n        for (let i = 0; i < len; i++) {\n            let item = arr[i]\n            let newArr = [].concat(arr.slice(0, i), arr.slice(i+1))\n            if (!newArr.includes(item)) {\n                target = item\n                break\n            }\n        }\n        return target\n    }\n")])])]),t("h2",{attrs:{id:"找出数组中第一个不重复的元素-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#找出数组中第一个不重复的元素-2"}},[n._v("#")]),n._v(" 找出数组中第一个不重复的元素")]),n._v(" "),t("h1",{attrs:{id:"剑指offer的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#剑指offer的"}},[n._v("#")]),n._v(" 剑指offer的")]),n._v(" "),t("h2",{attrs:{id:"用两个栈来实现一个队列-完成队列的push和pop操作。-队列中的元素为int类型。-简单"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#用两个栈来实现一个队列-完成队列的push和pop操作。-队列中的元素为int类型。-简单"}},[n._v("#")]),n._v(" 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。（简单）")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("    // 思路：栈（先进后出，数组），队列（先进先出）。从栈1取出数据放入栈2，就实现了第一个入栈1的数据，成了最后一个入栈2的数据。\n\n    // 定义栈，并实现栈的三种方法\n    function Stack() {\n        var item = []\n        this.push = function(node) {\n            item.push(node)\n        }\n        this.pop = function() {\n            return item.pop()\n        }\n        this.isEmpty = function() {\n            return item.length === 0\n        }\n    }\n    var stack1 = new Stack()\n    var stack2 = new Stack()\n    function push(node) {\n        // write code here\n        stack1.push(node)\n    }\n    function pop() {\n        // write code here\n        if (stack1.isEmpty() && stack2.isEmpty()) {\n            console.log('Queue is empty')\n        }\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop())\n            }\n        }\n        console.log(stack2.pop())\n    }\n")])])]),t("h2",{attrs:{id:"把一个数组最开始的若干个元素搬到数组的末尾-我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转-输出旋转数组的最小元素。例如数组-3-4-5-1-2-为-1-2-3-4-5-的一个旋转-该数组的最小值为1。note-给出的所有元素都大于0-若数组大小为0-请返回0。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#把一个数组最开始的若干个元素搬到数组的末尾-我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转-输出旋转数组的最小元素。例如数组-3-4-5-1-2-为-1-2-3-4-5-的一个旋转-该数组的最小值为1。note-给出的所有元素都大于0-若数组大小为0-请返回0。"}},[n._v("#")]),n._v(" 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组[3,4,5,1,2]为[1,2,3,4,5]的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("    // 思路：首先理解“非递减排序”，是指有增有平，例如[1,2,3,3,4,5]为非递减。其次观察旋转数组[3,3,4,5,1,2]特点，旋转后非递减性被破坏了，那么比前边数字小的那个数即为最小数。\n")])])])])}),[],!1,null,null,null);r.default=a.exports}}]);