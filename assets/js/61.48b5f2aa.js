(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{416:function(e,t,n){"use strict";n.r(t);var a=n(44),v=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"mvvm"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#mvvm"}},[e._v("#")]),e._v(" MVVM")]),e._v(" "),n("p",[e._v("在MVVM架构模式中，")]),e._v(" "),n("ul",[n("li",[e._v("M 指的是 Modal 即数据层，仅关注数据本身，不关心任何行为，可以理解为一个类似 JSON 的数据对象。")]),e._v(" "),n("li",[e._v("V 指的是 View 即视图层，通过模板语法声明式的将数据渲染进 DOM，Modal 的更新会通过 VM 层响应式地更新到 View。")]),e._v(" "),n("li",[e._v("VM 指的是 ViewModal，通过双向数据绑定的方式，实时的更新 V 和 M。")])]),e._v(" "),n("p",[e._v("在 Vue 中，双向数据绑定是采用数据劫持和发布-订阅模式实现的。")]),e._v(" "),n("h2",{attrs:{id:"双向数据绑定"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#双向数据绑定"}},[e._v("#")]),e._v(" 双向数据绑定")]),e._v(" "),n("p",[e._v("双向数据绑定指的是，View 改变可以实时更新 Modal(即数据)，而 Modal 的改变也能实时更新 View。")]),e._v(" "),n("p",[e._v("通过事件监听可以实现 View 改变实时更新 Modal，例如监听 input 的 input 事件，输入内容时更新 Modal 中的数据。")]),e._v(" "),n("p",[e._v("重点是 Modal 的改变如何实时的更新 View？")]),e._v(" "),n("p",[e._v("问题可抽象为 "),n("strong",[e._v("获知数据变化")]),e._v(" 和 "),n("strong",[e._v("响应数据变化")]),e._v("，这个过程涉及几个关键步骤：")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("如何获知 Modal 的改变？")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("数据劫持，Vue2.x 使用了 ES5 的 Object.defineProperty() 来劫持数据，为 data 中每个属性添加 getter 和 setter。")])]),e._v(" "),n("li",[n("p",[e._v("实现劫持，数据劫持的过程交由 "),n("strong",[e._v("监听器 Observer")]),e._v(" 来完成，伪代码如下：")]),e._v(" "),n("p",[e._v("function Observer(data) {\nfor (let key in data) {\nlet val = data[key]\nObserver(val)   // 递归调用，确保劫持到每个属性\nObject.defineProperty(data, key, {\nenumerable: true,\nget() {\nreturn val\n},\nset(newVal) {\nval = newVal\nconsole.log('获知数据改变')\n}\n})\n}\n}")])])]),e._v(" "),n("p",[e._v("那么当数据改变时，就会触发 set 函数，在此处就可以获知数据的改变。注：数据劫持过程仅为数据添加 get 和 set 函数，但是并未触发这两个函数。")])]),e._v(" "),n("li",[n("p",[e._v("更新哪些 View 元素？")]),e._v(" "),n("ul",[n("li",[e._v("Vue 模板语法中的模板变量是待更新的 View 元素")]),e._v(" "),n("li",[e._v("模板变量需经过解析才能转化为数据")]),e._v(" "),n("li",[n("strong",[e._v("解析器 Complie")]),e._v("用来执行解析过程，解析每个模板变量时，都会创建一个"),n("strong",[e._v("订阅者 Watcher")]),e._v("，创建 Watcher 时会调用数据的 get 方法。")])])]),e._v(" "),n("li",[n("p",[e._v("如何更新？")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("依赖收集，Vue 实现了"),n("strong",[e._v("订阅器 Dep")]),e._v("，Dep 有一个 addSub 方法，用来收集 Watcher，而 notify 方法用来遍历 Watcher(有个update方法) 执行更新。")]),e._v(" "),n("p",[e._v("function Dep() {\nthis.subs = []  // 存放 watcher\n}\nDep.prototype.addSub = function(watcher) {\nthis.subs.push(watcher)\n}\nDep.prototype.notify = function() {\nthis.subs.forEach(watcher => {\nwatcher.update()\n})\n}")])]),e._v(" "),n("li",[n("p",[e._v("解析过程执行 get 时，执行了 addSub 收集 Watcher。而更新数据时，执行了 set，此时会触发 Dep 的 notify 方法更新视图。")]),e._v(" "),n("p",[e._v("function Observer(data) {\nconst dep = new Dep()\nfor (let key in data) {\nlet val = data[key]\nObserver(val)   // 递归调用，确保劫持到每个属性\nObject.defineProperty(data, key, {\nenumerable: true,\nget() {\ndep.addSub(Watcher)     // 收集 Watcher\nreturn val\n},\nset(newVal) {\nval = newVal\ndep.notify()            // 更新视图\nconsole.log('获知数据改变')\n}\n})\n}\n}")])])])])]),e._v(" "),n("p",[n("em",[e._v("参考")]),e._v("：")]),e._v(" "),n("ul",[n("li",[e._v("https://www.jianshu.com/p/570a84ca7a30")]),e._v(" "),n("li",[e._v("https://www.jianshu.com/p/251235dd04c8")])])])}),[],!1,null,null,null);t.default=v.exports}}]);