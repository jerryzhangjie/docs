<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue 官网学习纪要 | 能量蓄水池</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/docs/favicon.svg">
    <meta name="description" content="学习笔记、知识文档、经验总结、生活杂记。">
    
    <link rel="preload" href="/docs/assets/css/0.styles.767e998a.css" as="style"><link rel="preload" href="/docs/assets/js/app.574fc7ba.js" as="script"><link rel="preload" href="/docs/assets/js/2.438c9cc2.js" as="script"><link rel="preload" href="/docs/assets/js/66.313ff872.js" as="script"><link rel="prefetch" href="/docs/assets/js/10.782efd2f.js"><link rel="prefetch" href="/docs/assets/js/11.9a017d0a.js"><link rel="prefetch" href="/docs/assets/js/12.8c3fe05c.js"><link rel="prefetch" href="/docs/assets/js/13.32b8501e.js"><link rel="prefetch" href="/docs/assets/js/14.7cbead99.js"><link rel="prefetch" href="/docs/assets/js/15.5ca6d375.js"><link rel="prefetch" href="/docs/assets/js/16.7b1d893e.js"><link rel="prefetch" href="/docs/assets/js/17.8243e47c.js"><link rel="prefetch" href="/docs/assets/js/18.f795c9b4.js"><link rel="prefetch" href="/docs/assets/js/19.e16fd372.js"><link rel="prefetch" href="/docs/assets/js/20.12825b32.js"><link rel="prefetch" href="/docs/assets/js/21.d2e3ba19.js"><link rel="prefetch" href="/docs/assets/js/22.a091a3f3.js"><link rel="prefetch" href="/docs/assets/js/23.1829b4d2.js"><link rel="prefetch" href="/docs/assets/js/24.41ea6154.js"><link rel="prefetch" href="/docs/assets/js/25.d944d918.js"><link rel="prefetch" href="/docs/assets/js/26.f9ba23ac.js"><link rel="prefetch" href="/docs/assets/js/27.33228142.js"><link rel="prefetch" href="/docs/assets/js/28.cc4b94e6.js"><link rel="prefetch" href="/docs/assets/js/29.e183b477.js"><link rel="prefetch" href="/docs/assets/js/3.ce6400d4.js"><link rel="prefetch" href="/docs/assets/js/30.f2b86e7a.js"><link rel="prefetch" href="/docs/assets/js/31.75faa4ac.js"><link rel="prefetch" href="/docs/assets/js/32.1813d3da.js"><link rel="prefetch" href="/docs/assets/js/33.c64ac273.js"><link rel="prefetch" href="/docs/assets/js/34.d54f07d6.js"><link rel="prefetch" href="/docs/assets/js/35.c6b17c27.js"><link rel="prefetch" href="/docs/assets/js/36.93273509.js"><link rel="prefetch" href="/docs/assets/js/37.f4f46233.js"><link rel="prefetch" href="/docs/assets/js/38.fa9900ec.js"><link rel="prefetch" href="/docs/assets/js/39.3b24b23d.js"><link rel="prefetch" href="/docs/assets/js/4.9b8751d4.js"><link rel="prefetch" href="/docs/assets/js/40.5728cc60.js"><link rel="prefetch" href="/docs/assets/js/41.9e47e643.js"><link rel="prefetch" href="/docs/assets/js/42.2cd430a0.js"><link rel="prefetch" href="/docs/assets/js/43.0e9a4cd9.js"><link rel="prefetch" href="/docs/assets/js/44.ec5e25b6.js"><link rel="prefetch" href="/docs/assets/js/45.4cdd4bf1.js"><link rel="prefetch" href="/docs/assets/js/46.b8a5de46.js"><link rel="prefetch" href="/docs/assets/js/47.544a1352.js"><link rel="prefetch" href="/docs/assets/js/48.75ab366d.js"><link rel="prefetch" href="/docs/assets/js/49.59e58f04.js"><link rel="prefetch" href="/docs/assets/js/5.6d67c780.js"><link rel="prefetch" href="/docs/assets/js/50.96ea067f.js"><link rel="prefetch" href="/docs/assets/js/51.144bb382.js"><link rel="prefetch" href="/docs/assets/js/52.8d9aac06.js"><link rel="prefetch" href="/docs/assets/js/53.06e2c5d4.js"><link rel="prefetch" href="/docs/assets/js/54.2d17b229.js"><link rel="prefetch" href="/docs/assets/js/55.7cda8245.js"><link rel="prefetch" href="/docs/assets/js/56.133756ab.js"><link rel="prefetch" href="/docs/assets/js/57.74959c99.js"><link rel="prefetch" href="/docs/assets/js/58.18ff2b44.js"><link rel="prefetch" href="/docs/assets/js/59.b35de2b8.js"><link rel="prefetch" href="/docs/assets/js/6.c3ae577d.js"><link rel="prefetch" href="/docs/assets/js/60.39380f27.js"><link rel="prefetch" href="/docs/assets/js/61.48b5f2aa.js"><link rel="prefetch" href="/docs/assets/js/62.c62037f3.js"><link rel="prefetch" href="/docs/assets/js/63.a439b062.js"><link rel="prefetch" href="/docs/assets/js/64.c24f247a.js"><link rel="prefetch" href="/docs/assets/js/65.e1fa1286.js"><link rel="prefetch" href="/docs/assets/js/67.b8bfc1ca.js"><link rel="prefetch" href="/docs/assets/js/68.f81bf7a5.js"><link rel="prefetch" href="/docs/assets/js/69.c420ebd2.js"><link rel="prefetch" href="/docs/assets/js/7.5229be7a.js"><link rel="prefetch" href="/docs/assets/js/70.f4bec417.js"><link rel="prefetch" href="/docs/assets/js/71.40db7b8a.js"><link rel="prefetch" href="/docs/assets/js/72.f297dce6.js"><link rel="prefetch" href="/docs/assets/js/73.2d73f227.js"><link rel="prefetch" href="/docs/assets/js/74.735fb235.js"><link rel="prefetch" href="/docs/assets/js/75.50f07148.js"><link rel="prefetch" href="/docs/assets/js/76.89a73abf.js"><link rel="prefetch" href="/docs/assets/js/77.66ba0d1e.js"><link rel="prefetch" href="/docs/assets/js/78.81c41079.js"><link rel="prefetch" href="/docs/assets/js/79.14a4fcbf.js"><link rel="prefetch" href="/docs/assets/js/8.30d4ce7d.js"><link rel="prefetch" href="/docs/assets/js/80.af5d096b.js"><link rel="prefetch" href="/docs/assets/js/81.4eccd1c7.js"><link rel="prefetch" href="/docs/assets/js/82.d069817a.js"><link rel="prefetch" href="/docs/assets/js/83.495cd329.js"><link rel="prefetch" href="/docs/assets/js/84.9489494e.js"><link rel="prefetch" href="/docs/assets/js/85.e4406d55.js"><link rel="prefetch" href="/docs/assets/js/86.71cff966.js"><link rel="prefetch" href="/docs/assets/js/87.5eba7956.js"><link rel="prefetch" href="/docs/assets/js/88.6670820c.js"><link rel="prefetch" href="/docs/assets/js/89.cc537610.js"><link rel="prefetch" href="/docs/assets/js/9.99b7e418.js"><link rel="prefetch" href="/docs/assets/js/90.6ccfe07d.js">
    <link rel="stylesheet" href="/docs/assets/css/0.styles.767e998a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/docs/" class="home-link router-link-active"><img src="/docs/favicon.svg" alt="能量蓄水池" class="logo"> <span class="site-name can-hide">能量蓄水池</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/docs/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/docs/about/" class="nav-link">
  关于
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><span class="title">技术</span> <span class="arrow down"></span></button> <button type="button" aria-label="技术" class="mobile-dropdown-title"><span class="title">技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/technology/1. 前端/" class="nav-link">
  前端
</a></li><li class="dropdown-item"><!----> <a href="/docs/technology/2. 服务端/" class="nav-link">
  服务端
</a></li><li class="dropdown-item"><!----> <a href="/docs/technology/3. 其它/" class="nav-link">
  其它
</a></li></ul></div></div><div class="nav-item"><a href="/docs/life/" class="nav-link">
  生活杂记
</a></div><div class="nav-item"><a href="/docs/other/" class="nav-link">
  其它
</a></div> <a href="https://github.com/jerryzhangjie/docs" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/docs/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/docs/about/" class="nav-link">
  关于
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><span class="title">技术</span> <span class="arrow down"></span></button> <button type="button" aria-label="技术" class="mobile-dropdown-title"><span class="title">技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/technology/1. 前端/" class="nav-link">
  前端
</a></li><li class="dropdown-item"><!----> <a href="/docs/technology/2. 服务端/" class="nav-link">
  服务端
</a></li><li class="dropdown-item"><!----> <a href="/docs/technology/3. 其它/" class="nav-link">
  其它
</a></li></ul></div></div><div class="nav-item"><a href="/docs/life/" class="nav-link">
  生活杂记
</a></div><div class="nav-item"><a href="/docs/other/" class="nav-link">
  其它
</a></div> <a href="https://github.com/jerryzhangjie/docs" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>1.1 基础 - ECMAScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>1.2 基础 - CSS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>1.3 基础 - HTML</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>1.4 浏览器</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>1.5 网络</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>1.6 设计模式</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>1.7 算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>1.8 框架</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/technology/1. 前端/1.8 框架/electron-基础入门.html" class="sidebar-link">electron-基础入门</a></li><li><a href="/docs/technology/1. 前端/1.8 框架/jQuery.html" class="sidebar-link">jQuery</a></li><li><a href="/docs/technology/1. 前端/1.8 框架/react-Mobx.html" class="sidebar-link">react-Mobx</a></li><li><a href="/docs/technology/1. 前端/1.8 框架/react-React 简书.html" class="sidebar-link">react-React 简书</a></li><li><a href="/docs/technology/1. 前端/1.8 框架/react-React.html" class="sidebar-link">react-React</a></li><li><a href="/docs/technology/1. 前端/1.8 框架/Vite原理与实现.html" class="sidebar-link">Vite原理与实现</a></li><li><a href="/docs/technology/1. 前端/1.8 框架/vue-Object.defineProperty与双向数据绑定.html" class="sidebar-link">vue-Object.defineProperty与双向数据绑定</a></li><li><a href="/docs/technology/1. 前端/1.8 框架/vue-VueRouter.html" class="sidebar-link">vue-VueRouter</a></li><li><a href="/docs/technology/1. 前端/1.8 框架/vue-Vuex.html" class="sidebar-link">vue-Vuex</a></li><li><a href="/docs/technology/1. 前端/1.8 框架/vue-Vue的diff算法.html" class="sidebar-link">vue-Vue的diff算法</a></li><li><a href="/docs/technology/1. 前端/1.8 框架/vue-作用域插槽.html" class="sidebar-link">vue-作用域插槽</a></li><li><a href="/docs/technology/1. 前端/1.8 框架/vue-官网学习纪要.html" class="active sidebar-link">vue-官网学习纪要</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/technology/1. 前端/1.8 框架/vue-官网学习纪要.html#_1" class="sidebar-link">1.</a></li><li class="sidebar-sub-header"><a href="/docs/technology/1. 前端/1.8 框架/vue-官网学习纪要.html#_2" class="sidebar-link">2.</a></li><li class="sidebar-sub-header"><a href="/docs/technology/1. 前端/1.8 框架/vue-官网学习纪要.html#_3" class="sidebar-link">3.</a></li><li class="sidebar-sub-header"><a href="/docs/technology/1. 前端/1.8 框架/vue-官网学习纪要.html#_4" class="sidebar-link">4.</a></li><li class="sidebar-sub-header"><a href="/docs/technology/1. 前端/1.8 框架/vue-官网学习纪要.html#_5" class="sidebar-link">5.</a></li><li class="sidebar-sub-header"><a href="/docs/technology/1. 前端/1.8 框架/vue-官网学习纪要.html#_6" class="sidebar-link">6.</a></li><li class="sidebar-sub-header"><a href="/docs/technology/1. 前端/1.8 框架/vue-官网学习纪要.html#_7" class="sidebar-link">7.</a></li><li class="sidebar-sub-header"><a href="/docs/technology/1. 前端/1.8 框架/vue-官网学习纪要.html#_8" class="sidebar-link">8.</a></li><li class="sidebar-sub-header"><a href="/docs/technology/1. 前端/1.8 框架/vue-官网学习纪要.html#_9" class="sidebar-link">9.</a></li><li class="sidebar-sub-header"><a href="/docs/technology/1. 前端/1.8 框架/vue-官网学习纪要.html#_10" class="sidebar-link">10.</a></li><li class="sidebar-sub-header"><a href="/docs/technology/1. 前端/1.8 框架/vue-官网学习纪要.html#_11" class="sidebar-link">11.</a></li><li class="sidebar-sub-header"><a href="/docs/technology/1. 前端/1.8 框架/vue-官网学习纪要.html#_12" class="sidebar-link">12.</a></li><li class="sidebar-sub-header"><a href="/docs/technology/1. 前端/1.8 框架/vue-官网学习纪要.html#_13" class="sidebar-link">13.</a></li><li class="sidebar-sub-header"><a href="/docs/technology/1. 前端/1.8 框架/vue-官网学习纪要.html#_14" class="sidebar-link">14.</a></li><li class="sidebar-sub-header"><a href="/docs/technology/1. 前端/1.8 框架/vue-官网学习纪要.html#_15-v-if、v-show、visibility、display" class="sidebar-link">15. v-if、v-show、visibility、display</a></li><li class="sidebar-sub-header"><a href="/docs/technology/1. 前端/1.8 框架/vue-官网学习纪要.html#_16-v-for、for-in、for-of" class="sidebar-link">16. v-for、for...in、for...of</a></li><li class="sidebar-sub-header"><a href="/docs/technology/1. 前端/1.8 框架/vue-官网学习纪要.html#_17" class="sidebar-link">17.</a></li><li class="sidebar-sub-header"><a href="/docs/technology/1. 前端/1.8 框架/vue-官网学习纪要.html#_18" class="sidebar-link">18.</a></li><li class="sidebar-sub-header"><a href="/docs/technology/1. 前端/1.8 框架/vue-官网学习纪要.html#_19-数组操作" class="sidebar-link">19. 数组操作</a></li><li class="sidebar-sub-header"><a href="/docs/technology/1. 前端/1.8 框架/vue-官网学习纪要.html#_20" class="sidebar-link">20.</a></li><li class="sidebar-sub-header"><a href="/docs/technology/1. 前端/1.8 框架/vue-官网学习纪要.html#_21-is" class="sidebar-link">21. is</a></li><li class="sidebar-sub-header"><a href="/docs/technology/1. 前端/1.8 框架/vue-官网学习纪要.html#_22-v-on" class="sidebar-link">22. v-on(@)</a></li><li class="sidebar-sub-header"><a href="/docs/technology/1. 前端/1.8 框架/vue-官网学习纪要.html#_23-v-model" class="sidebar-link">23. v-model</a></li><li class="sidebar-sub-header"><a href="/docs/technology/1. 前端/1.8 框架/vue-官网学习纪要.html#组件注册" class="sidebar-link">组件注册</a></li><li class="sidebar-sub-header"><a href="/docs/technology/1. 前端/1.8 框架/vue-官网学习纪要.html#prop" class="sidebar-link">Prop</a></li><li class="sidebar-sub-header"><a href="/docs/technology/1. 前端/1.8 框架/vue-官网学习纪要.html#自定义事件" class="sidebar-link">自定义事件</a></li><li class="sidebar-sub-header"><a href="/docs/technology/1. 前端/1.8 框架/vue-官网学习纪要.html#插槽" class="sidebar-link">插槽</a></li><li class="sidebar-sub-header"><a href="/docs/technology/1. 前端/1.8 框架/vue-官网学习纪要.html#动态组件" class="sidebar-link">动态组件</a></li><li class="sidebar-sub-header"><a href="/docs/technology/1. 前端/1.8 框架/vue-官网学习纪要.html#依赖注入" class="sidebar-link">依赖注入</a></li><li class="sidebar-sub-header"><a href="/docs/technology/1. 前端/1.8 框架/vue-官网学习纪要.html#自定义指令" class="sidebar-link">自定义指令</a></li><li class="sidebar-sub-header"><a href="/docs/technology/1. 前端/1.8 框架/vue-官网学习纪要.html#过滤器" class="sidebar-link">过滤器</a></li><li class="sidebar-sub-header"><a href="/docs/technology/1. 前端/1.8 框架/vue-官网学习纪要.html#如何看待关注点分离-如何看待vue的单文件组件" class="sidebar-link">如何看待关注点分离(如何看待Vue的单文件组件)？</a></li></ul></li><li><a href="/docs/technology/1. 前端/1.8 框架/vue-慕课网实战 - 去哪儿网学习纪要.html" class="sidebar-link">vue-慕课网实战 - 去哪儿网学习纪要</a></li><li><a href="/docs/technology/1. 前端/1.8 框架/vue-源码学习.html" class="sidebar-link">vue-源码学习</a></li><li><a href="/docs/technology/1. 前端/1.8 框架/vue-组件命名及引用规范.html" class="sidebar-link">vue-组件命名及引用规范</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>1.9 实践及总结</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>1.10 工程化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>1.11 Other</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue-官网学习纪要"><a href="#vue-官网学习纪要" class="header-anchor">#</a> Vue 官网学习纪要</h1> <blockquote><p>整理记录之前学习中疏忽、遗漏、不理解的知识点，对其进行排查和深究，以期更好的掌握Vue基础知识。</p></blockquote> <h1 id="基础"><a href="#基础" class="header-anchor">#</a> 基础</h1> <hr> <h2 id="_1"><a href="#_1" class="header-anchor">#</a> 1.</h2> <blockquote><p><strong>Vue不支持 IE8 及以下版本，因为 Vue 使用了 IE8 无法模拟的 ECMAScript 5 特性。</strong></p></blockquote> <p>具体是什么特性？
<strong>Object.defineProperty()</strong></p> <blockquote><p>当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。</p></blockquote> <p>深入理解：详见<a href="/docs/technology/1. 前端/1.8 框架/Object.defineProperty与双向数据绑定.html">Object.defineProperty与双向数据绑定</a></p> <hr> <h2 id="_2"><a href="#_2" class="header-anchor">#</a> 2.</h2> <p>什么是<strong>CDN</strong>？
IDC、云计算、CDN之间什么关系？</p> <p><strong>理解</strong>：CDN全称Content Delivery Network，即内容分发网络，指通过互联网与各种缓存服务器（基于IDC）相连的网络系统。CDN是用来给网站加速的。用户请求CDN资源时，利用全局负载技术，将访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。
IDC全称Internet Data Center，即互联网数据中心，简称IDC机房。是云计算和CDN的基础，是整个互联网世界的大后方。
云计算可以理解为通过一些计算方式，将共享的软、硬件资源和信息，整个一起，形成一个大型虚拟资源池，资源取用更加便捷、灵活，有效提升了资源再分配的效率和规模，以及平台运作的效率。所以，云计算是以IDC为依托的上层建筑。</p> <p>查阅可知，目前主流的云服务提供商(阿里云、七牛云、腾讯云等)也是主流的CDN服务商，因为这两项服务都基于硬件——IDC的存在，而这些IDC大概率都是这些服务商搭建的。</p> <hr> <h2 id="_3"><a href="#_3" class="header-anchor">#</a> 3.</h2> <blockquote><p>运行时 + 编译器 vs. 只包含运行时</p></blockquote> <p>什么是 <strong>运行时</strong>、<strong>编译器</strong>？两种版本什么区别？</p> <blockquote><p><strong>编译器</strong>：用来将模板字符串编译成为 JavaScript 渲染函数的代码。
<strong>运行时</strong>：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。</p></blockquote> <blockquote><p>如果你需要在客户端编译模板 (比如传入一个字符串给 <code>template</code> 选项，或挂载到一个元素上并以其 DOM 内部的 HTML 作为模板)，就将需要加上编译器，即完整版：</p></blockquote> <div class="language- extra-class"><pre><code>// 需要编译器
new Vue({
    template: '&lt;div&gt;&lt;/div&gt;'   // 模板字符串
})

// 不需要编译器
new Vue({
    render (h) {
        return h('div', this.hi)    // js渲染函数
    }
})
</code></pre></div><p>当使用预处理器 <code>vue-loader</code> 时(通常配置在webpack配置项中)，.vue文件内的模板会在构建(npm run build)时预编译成js渲染函数。因为运行时版本相比完整版体积要小大约 30%，所以应该尽可能使用这个版本。</p> <hr> <h2 id="_4"><a href="#_4" class="header-anchor">#</a> 4.</h2> <p><strong>安装淘宝镜像：</strong></p> <div class="language- extra-class"><pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.org
</code></pre></div><hr> <h2 id="_5"><a href="#_5" class="header-anchor">#</a> 5.</h2> <blockquote><p>是一套用于构建用户界面的<strong>渐进式框架</strong>。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，...</p></blockquote> <p>何为<strong>渐进式框架</strong>？何为<strong>自底向上逐层应用</strong>？</p> <p>理解：渐进式简单来说，你使用Vue，可以只使用它的核心功能甚至其中几个指令实现视图渲染，也可以深入使用它的双向绑定、单文件组件，或者进一步用它来做单页面应用，并引入路由vue-router、状态管理vuex等等。也就是说，可以用Vue实现简单需求，也可以用Vue配合其它技术实现更复杂需求，甚至服务端渲染。而自底向上可以认为是由基础到复杂，由局部化到系统化构建项目的过程。</p> <hr> <h2 id="_6"><a href="#_6" class="header-anchor">#</a> 6.</h2> <blockquote><p><strong>Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统</strong></p></blockquote> <p>何为<strong>声明式渲染</strong>？
<a href="https://www.zhihu.com/question/68121329" target="_blank" rel="noopener noreferrer">怎么理解“声明式渲染”<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <code>声明式渲染</code>是与<code>命令式渲染</code>相对应的概念。
既然都是“渲染”，自然与浏览器中dom的渲染机制有关。<a href="">详见“浏览器渲染原理”</a>
**命令式渲染：**需要通过操作dom，控制dom按照业务逻辑一步步完成重新渲染过程。
**声明式渲染：**无需操作dom，只需将声明好的变量嵌入dom中，通过控制变量值的改变实现重新渲染。</p> <hr> <h2 id="_7"><a href="#_7" class="header-anchor">#</a> 7.</h2> <blockquote><p><strong>所有的Vue组件都是Vue实例，并且接受相同的选项对象(一些根实例特有的选项除外)</strong></p></blockquote> <p><strong>vue-cli单间的SPA中只有一个new，如何理解每个组件都是实例？</strong></p> <p>SPA中唯一的new是根实例，而通过import使用的.vue组件，其实例化过程交给了vue-loader来完成，它们本质上都是实例。</p> <hr> <h2 id="_8"><a href="#_8" class="header-anchor">#</a> 8.</h2> <p><strong>如何理解Vue遵循MVVM模型？</strong></p> <p><img src="https://gitee.com/jerry-zhang/image-database/raw/master/img/5d07951e1bef976565.png" alt=""></p> <hr> <h2 id="_9"><a href="#_9" class="header-anchor">#</a> 9.</h2> <blockquote><p><strong>当一个 Vue 实例被创建时，它将 data 对象中的所有的属性加入到 Vue 的响应式系统中</strong></p></blockquote> <ul><li><strong>实例创建时：</strong> 只有实例化时data中的属性才是响应式的，实例化之后向实例对象添加的属性，不具有响应式。</li> <li><strong>响应式系统：</strong> 属性值改变时，Vue将通知视图更新数据。</li></ul> <p>使用时，自定义属性与Vue自带的实例属性、方法的区别是，自带的都有前缀$</p> <hr> <h2 id="_10"><a href="#_10" class="header-anchor">#</a> 10.</h2> <blockquote><p><strong>不要在选项属性或回调上使用箭头函数，比如 created: () =&gt; console.log(this.a) 或 vm.$watch('a', newValue =&gt; this.myMethod())。因为箭头函数并没有 this，this 会作为变量一直向上级词法作用域查找，直至找到为止</strong></p></blockquote> <p>原因：因为箭头函数是和父级上下文绑定在一起的，this不会是Vue实例。<br>
注意：created() {} 是ES6函数声明的简写形式，不是箭头函数。</p> <hr> <h2 id="_11"><a href="#_11" class="header-anchor">#</a> 11.</h2> <blockquote><p><strong>生命周期</strong></p></blockquote> <p><img src="https://gitee.com/jerry-zhang/image-database/raw/master/img/5d0a229af2e1156221.png" alt=""></p> <hr> <h2 id="_12"><a href="#_12" class="header-anchor">#</a> 12.</h2> <blockquote><p>模板表达式都被放在沙盒中，只能访问全局变量的一个白名单，如 Math 和 Date 。你不应该在模板表达式中试图访问用户定义的全局变量。</p></blockquote> <p>意思是vue模版中，可以使用表达式，例如：<code>NaN</code>或<code>&lt;p :&quot;number + 1&quot;&gt;&lt;/p&gt;</code>，其中number是实例中定义的数据。当需要使用全局变量时，只能使用JS语言默认的全局变量，例如Math、Date等，而不能使用自定义的全局变量，例如定义了<code>window.myVar = 11</code>，不能在模版表达式中使用myVar。</p> <hr> <h2 id="_13"><a href="#_13" class="header-anchor">#</a> 13.</h2> <blockquote><p>计算属性</p></blockquote> <blockquote><p>计算属性是基于它们的响应式依赖进行缓存的，Date.now() 不是响应式依赖：</p></blockquote> <div class="language- extra-class"><pre><code>computed: {
    now: function () {
        return Date.now()
    }
}
</code></pre></div><p>原因：Date.now() 不是 响应依赖，因为它跟 Vue 的数据观察系统无关。
所以，使用计算属性时，一定要针对实例属性数据进行定义，否则计算属性将不会动态变化。</p> <hr> <h2 id="_14"><a href="#_14" class="header-anchor">#</a> 14.</h2> <blockquote><p>class与style绑定</p></blockquote> <div class="language- extra-class"><pre><code>&lt;div
    class=&quot;static&quot;
    v-bind:class=&quot;{ active: isActive, 'text-danger': hasError }&quot;
&gt;&lt;/div&gt;
</code></pre></div><p>注意：对象写法可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用<strong>引号括起来</strong>) 来命名。</p> <p>数组写法中，也可以混合对象写法使用：</p> <p><code>&lt;div v-bind:class=&quot;[{ active: isActive }, errorClass]&quot;&gt;&lt;/div&gt;</code></p> <blockquote><p>在一个自定义组件上使用 class 属性时，这些类将被添加到该组件的根元素上面，例如：</p></blockquote> <p><code>&lt;my-component class=&quot;baz boo&quot;&gt;&lt;/my-component&gt;</code></p> <p>HTML 将被渲染为:</p> <p><code>&lt;p class=&quot;foo bar baz boo&quot;&gt;Hi&lt;/p&gt;</code></p> <p>当 v-bind:style 使用需要添加浏览器引擎前缀的 CSS 属性时，如 transform，Vue.js 会自动侦测并添加相应的前缀。</p> <p><code>&lt;div :style=&quot;{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }&quot;&gt;&lt;/div&gt;</code></p> <p>这样写只会渲染数组中最后一个被浏览器支持的值。在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 display: flex。</p> <hr> <h2 id="_15-v-if、v-show、visibility、display"><a href="#_15-v-if、v-show、visibility、display" class="header-anchor">#</a> 15. v-if、v-show、visibility、display</h2> <p>v-if 切换dom时，会尽可能的复用相同标签名元素(例如<code>input</code>)，若不希望复用，只需在相同标签名元素上添加一个具有唯一值的 key 属性即可。</p> <blockquote><p>v-if 对比 v-show(display)</p></blockquote> <p>首先比较 <code>visibility:hidden;</code> 与 <code>display:none;</code></p> <p>二者共同点：</p> <ul><li>1.都使元素不可见；</li> <li>2.值变化时，都会触发浏览的重绘。</li> <li>3.仍存在dom tree中(与是否占据dom空间不是一个概念)。</li></ul> <p>二者不同点：<code>visibility: hidden;</code>仍然占据dom空间，后面的元素不会覆盖其位置，造成空白区域，即值改变只会重绘不会重排，而<code>display:none;</code>不会占据dom空间，后面的元素不会覆盖其位置，即值改变既会重绘又会重排。</p> <p>其次比较 <code>v-if</code> 与 <code>v-show</code></p> <blockquote><p>v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS 属性 display。</p></blockquote> <p>而<code>v-if</code>是彻底的插入或删除元素，删除后dom tree中不存在(注意与上述第3点不同)，所以我认为有些文章描述的<code>v-if</code>是<code>visibility</code>实现的，是不对的。</p> <blockquote><p>v-show 不支持 <code>&lt;template&gt;</code> 元素，也不支持 v-else。</p></blockquote> <blockquote><p>一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</p></blockquote> <blockquote><p>不推荐同时使用 v-if 和 v-for。当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。</p></blockquote> <hr> <h2 id="_16-v-for、for-in、for-of"><a href="#_16-v-for、for-in、for-of" class="header-anchor">#</a> 16. v-for、for...in、for...of</h2> <p><strong>for...in VS for...of ？</strong></p> <p>JS中：</p> <ul><li>for...in 以不确定顺序的方式遍历对象或数组的可枚举属性key(包括继承来的属性key)</li> <li>for...of 以希望的顺序遍历可迭代对象或数组的数据(属性值，而非key)</li></ul> <p>VUE的<code>v-for</code>中：
数组：二者无差异，均是以希望的顺序遍历数组的数据
对象：均以不确定的顺序遍历对象</p> <hr> <h2 id="_17"><a href="#_17" class="header-anchor">#</a> 17.</h2> <p>当需要使用v-if切换多个元素时，可使用<code>&lt;template&gt;</code>元素包裹想要切换的元素，<code>&lt;template&gt;</code>常作为不需要被渲染的包裹元素使用。</p> <hr> <h2 id="_18"><a href="#_18" class="header-anchor">#</a> 18.</h2> <p>vue会尽可能的复用相同的元素，如果不想复用，只需给相同的元素添加不同的key值。</p> <hr> <h2 id="_19-数组操作"><a href="#_19-数组操作" class="header-anchor">#</a> 19. 数组操作</h2> <ul><li><p>vue中响应式修改数组的方法有：</p> <ol><li>使用变异方法（push、pop、shift、unshift、splice、sort、reverse共7个）直接修改原数组，eg：vm.items.push('aa'); 所谓变异方法是指会改变原来值的方法，即使原数组变异了。</li> <li>将一个新数组赋值给原数组。</li> <li>使用全局方法或实例方法：Vue.set(vm.items, 6, 'aa') 或 vm.$set(vm.items, 6, 'aa')</li></ol></li> <li><p>vue中无法响应式修改数组的常见情况：</p> <ol><li>利用索引设置数组项，vm.items[6] = 'aa'</li> <li>修改数组的长度，vm.items.length = 6</li></ol></li> <li><p>vue中响应式修改对象的方法有：</p> <ol><li>将一个新对象赋值给原对象。</li> <li>使用全局方法或实例方法：</li></ol> <div class="language- extra-class"><pre class="language-text"><code>Vue.set(vm.userProfile, 'age', 27)
vm.$set(vm.userProfile, 'age', 27)
// 若需要添加多个（使用方法1进行赋值）
vm.userProfile = Object.assign({}, vm.userProfile, {
  age: 27,
  favoriteColor: 'Vue Green'
})
</code></pre></div></li></ul> <hr> <h2 id="_20"><a href="#_20" class="header-anchor">#</a> 20.</h2> <p>v-for也可以接受整数，此时它会把模版重复对应次数</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div&gt;
  &lt;span v-for=&quot;n in 10&quot;&gt;{{ n }} &lt;/span&gt;
&lt;/div&gt;
</code></pre></div><hr> <h2 id="_21-is"><a href="#_21-is" class="header-anchor">#</a> 21. is</h2> <p>想在ul、ol、select等有固定子元素(li、li、option)的元素中使用组件使，可使用<code>is</code>属性</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;ul&gt;
  &lt;li
    is=&quot;todo-item&quot;
    v-for=&quot;(todo, index) in todos&quot;
    v-bind:key=&quot;todo.id&quot;
    v-bind:title=&quot;todo.title&quot;
  &gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre></div><hr> <h2 id="_22-v-on"><a href="#_22-v-on" class="header-anchor">#</a> 22. v-on(@)</h2> <ul><li><p>v-on函数调用方法：</p> <ol><li>@click=&quot;handleClick&quot; —— 直接函数名，函数中可使用event获取dom事件对象</li> <li>@click=&quot;handleClick('123')&quot; —— 只传参数</li> <li>@click=&quot;handleClick('123', $event)&quot; —— 既传参数又传dom事件对象</li></ol> <div class="language- extra-class"><pre class="language-text"><code>handleClick: function (message, event) {
  // 现在我们可以访问原生事件对象
  if (event) event.preventDefault()
  alert(message)
}
</code></pre></div></li> <li><p>事件修饰符</p> <ol><li>.stop 是stopPropagation()的语法糖，阻止事件冒泡</li> <li>.prevent 是preventDefault()的语法糖，阻止事件默认行为，例如表单提交时重载页面</li> <li>.capture 使用事件捕获模式，即元素自身触发的事件先在此处理，然后才交由内部元素进行处理</li> <li>.self 事件是自身触发的才会执行，即事件不能是捕获或冒泡而来的事件</li> <li>.once 只执行一次</li> <li>.passive 滚动行为结束后才会触发</li></ol></li> <li><p>按键别名或按键码修饰符</p> <ol><li>.enter 当按键为回车时才会触发，例如 @keyup.enter=&quot;handleEnter&quot;</li> <li>.13 当按键为回车时才会触发，例如 @keyup.13=&quot;handleEnter&quot;</li></ol> <div class="language- extra-class"><pre class="language-text"><code>// 通过全局config.keyCodes自定义按键码别名
// 可以使用 `v-on:keyup.f1`
Vue.config.keyCodes.f1 = 112
</code></pre></div></li> <li><p>.exact 修饰符允许你控制由精确的系统修饰符组合触发的事件</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;
&lt;button @click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;

&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;
&lt;button @click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;

&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;
&lt;button @click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt;
</code></pre></div></li> <li><p>使用v-on在HTML中监听事件，跟传统的js绑定相比，有什么好处？</p> <ol><li>直观定位事件的绑定位置；</li> <li>无需js中手动绑定，避免操作dom，实现了与dom解耦；</li> <li>vue.js事件都绑定在当前视图的ViewModel上，当当前实例销毁时，事件处理器也将自动销毁。</li></ol></li></ul> <hr> <h2 id="_23-v-model"><a href="#_23-v-model" class="header-anchor">#</a> 23. v-model</h2> <ul><li>取值</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;!-- `toggle` 为 true 或 false --&gt;
&lt;input type=&quot;checkbox&quot; v-model=&quot;toggle&quot;&gt;
&lt;!-- checkedNames 为数组，元素为value值 --&gt;
&lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt;
&lt;input type=&quot;checkbox&quot; id=&quot;john&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot;&gt;
&lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt;
&lt;!-- 当选中时，`picked` 为字符串 &quot;a&quot; --&gt;
&lt;input type=&quot;radio&quot; v-model=&quot;picked&quot; value=&quot;a&quot;&gt;
&lt;!-- 当选中时，`picked` 为字符串 true --&gt;
&lt;input type=&quot;radio&quot; v-model=&quot;picked&quot;&gt;
</code></pre></div><ul><li>修饰符
<ul><li>.lazy 默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步。lazy可避免如此频繁的数据同步，仅在change事件触发时同步数据(通常是失去焦点时触发change事件)</li> <li>.number 自动将用户的输入转化为数字类型。无法被 parseFloat() 解析，则会返回原始的值</li></ul> <div class="language- extra-class"><pre class="language-text"><code>    &lt;!-- 输入 —— 返回 --&gt;
    21 —— 21
    21aaa —— 21
    aaa —— aaa
    aaa21 —— aaa21
</code></pre></div><ul><li>.trim 删除首尾空格</li></ul></li></ul> <hr> <h2 id="组件注册"><a href="#组件注册" class="header-anchor">#</a> 组件注册</h2> <ul><li>组件分为全局组件和局部组件。vue-cli项目中通过<code>import</code>引入，然后实例中通过<code>components</code>注册的单文件组件，都是局部组件。对于在很多组件中都会用到的基础组件，应该注册成全局组件，以下是Vue官方的一个将单文件组件注册成全局组件的例子：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;!-- 引入lodash(一个 JavaScript 的实用工具库)中的方法 --&gt;
import upperFirst from 'lodash/upperFirst'
import camelCase from 'lodash/camelCase'

&lt;!-- require.context获取单文件组件对象 --&gt;
const requireComponent = require.context(
  // 其组件目录的相对路径
  './components',
  // 是否查询其子目录
  false,
  // 匹配基础组件文件名的正则表达式
  /Base[A-Z]\w+\.(vue|js)$/
)

requireComponent.keys().forEach(fileName =&gt; {
  // 获取组件配置
  const componentConfig = requireComponent(fileName)
  // 获取组件的 PascalCase 命名
  const componentName = upperFirst(
    camelCase(
      // 获取和目录深度无关的文件名
      fileName
        .split('/')
        .pop()
        .replace(/\.\w+$/, '')
    )
  )

  // 全局注册组件
  Vue.component(
    componentName,
    // 如果这个组件选项是通过 `export default` 导出的，
    // 那么就会优先使用 `.default`，
    // 否则回退到使用模块的根。
    componentConfig.default || componentConfig
  )
})
</code></pre></div><p>注：全局组件应该在根实例之前定义。</p> <ul><li>组件上使用<code>v-model</code>
组件上无法直接使用<code>v-model</code>，需借助组件的事件自定义事件，对组件内的<code>input</code>做如下处理：
<ul><li>将其<code>value</code>特性绑定到一个名叫<code>value</code>的<code>prop</code>上</li> <li>在其<code>input</code>事件被触发时，将新的值通过自定义的<code>input</code>事件抛出</li></ul></li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 使用组件custom-input
&lt;custom-input v-model=&quot;searchText&quot;&gt;&lt;/custom-input&gt;
// 定义组件
Vue.component('custom-input', {
  props: ['value'], // 因为v-model固定对应value这种属性，所以prop只有叫value，才能接收到v-model传进来的值
  template: `
    &lt;input
      v-bind:value=&quot;value&quot;  // 将prop赋值给input的value，才能父组件传来的值显示在input中
      v-on:input=&quot;$emit('input', $event.target.value)&quot;  // 因为v-model固定对应input标签的input这种事件，所以自定义事件名只有叫input，父组件才能通过v-model拿到子组件中传来的值
    &gt;
  `
})
</code></pre></div><hr> <h2 id="prop"><a href="#prop" class="header-anchor">#</a> Prop</h2> <ul><li>prop验证
<ul><li>type 类型检查，值：原生构造函数(String、Number、Boole Boolean、Array、Object、Date、Function、Symbol) 或 自定义构造函数(利于定义的叫做Person的构造函数名称)</li> <li>required 是否必须，值：true、false</li> <li>default 默认值</li> <li>validator 自定义验证函数</li></ul> <div class="language- extra-class"><pre class="language-text"><code>  // 自定义验证函数
  propF: {
    validator: function (value) {
      // 属性值必须匹配下列字符串中的一个(或验证是否匹配一个正则)
      return ['success', 'warning', 'danger'].indexOf(value) !== -1
    }
  }
</code></pre></div></li> <li>非prop特性
非prop特性是指，传向子组件，但是子组件中并未声明的属性。
<ul><li>继承性 - 通常非prop特性会添加到/替换掉子组件的根节点的相应属性，特殊的，class和style会被合并到子组件的根节点的class和style上</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 子组件
&lt;input type=&quot;date&quot; class=&quot;child&quot; /&gt;
// 调用组件
&lt;my-component type=&quot;text&quot; data-aa='xxx' class=&quot;father&quot;&gt;&lt;/my-component&gt;
// 渲染结果
&lt;input type=&quot;text&quot; data-aa='xxx' class=&quot;child father&quot; /&gt;
</code></pre></div><ul><li>禁用继承 - 如果不想子组件的根节点默认继承非prop特性，可在组件选项中添加<code>inheritAttrs: false</code>，并在希望获得继承的节点上使用<code>$attrs</code>对象(该对象包含作用在该组件上的所有属性)</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 子组件
&lt;div&gt; // 禁止根节点获取继承属性
  &lt;input  // 希望该节点获取继承属性
    v-bind=&quot;$attrs&quot; // 通过$attrs获取继承
  &gt;
&lt;/div&gt;
new Vue({
  inheritAttrs: false,
  ...
})
// 调用组件
&lt;my-component type=&quot;text&quot; title=&quot;hahaha&quot;&gt;&lt;/my-component&gt;
// 渲染结果
&lt;div&gt; // 根节点未获取继承属性
  &lt;input  // 该节点获取了继承属性
    type=&quot;text&quot;
    title=&quot;hahaha&quot;
  &gt;
&lt;/div&gt;
</code></pre></div></li></ul> <hr> <h2 id="自定义事件"><a href="#自定义事件" class="header-anchor">#</a> 自定义事件</h2> <ul><li>原生事件绑定到组件：
<ul><li>当在调用子组件时绑定原生事件，如<code>v-on:focus.native=&quot;onFocus&quot;</code>这样调用时，类似非prop特性，该事件将被绑定到子组件的根节点。</li> <li>若根节点是你的目标节点，这样绑定没问题，但如果不希望绑定到根节点，应该利用<code>$listeners</code>对象，获取绑定在该组件上的所有事件。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;input
  v-bind=&quot;$attrs&quot;
  v-on=&quot;inputListeners&quot;
&gt;
new Vue({
  computed: {
    inputListeners() {
      return Object.assign({}, this.$listeners)
    }
  }
})
</code></pre></div></li> <li>.sync
作用是，子组件希望通知父组件改变prop值，进而实现子组件的展示(或逻辑)。<div class="language- extra-class"><pre class="language-text"><code>// 调用，作用于prop foo上
&lt;my-component :foo.sync=&quot;bar&quot;&gt;&lt;/my-component&gt;
// 子组件中，通过update通知父组件更新foo的值
this.$emit('update:foo', newValue)

// 等价于
&lt;my-component :foo=&quot;bar&quot; @update:foo=&quot;val =&gt; bar = val&quot;&gt;&lt;/my-component&gt;
this.$emit('update:foo', newValue)
</code></pre></div>当然，相同的效果，也可通过自定义事件实现，所以 <code>.sync</code> 只是个语法糖。</li></ul> <hr> <h2 id="插槽"><a href="#插槽" class="header-anchor">#</a> 插槽</h2> <ul><li>基本用法</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 组件 BaseLayout
&lt;div class=&quot;container&quot;&gt;
  &lt;header&gt;
    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;
  &lt;/header&gt;
  &lt;main&gt;
    &lt;slot&gt;default text&lt;/slot&gt; // 未传入插槽内容时，default text才会显示
  &lt;/main&gt;
  &lt;footer&gt;
    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;
  &lt;/footer&gt;
&lt;/div&gt;
// 调用
&lt;base-layout&gt;
  &lt;template v-slot:header&gt;
    &lt;h1&gt;Here might be a page title&lt;/h1&gt;
  &lt;/template&gt;

  &lt;template v-slot:default&gt; // 默认插槽的template可省略
    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;
    &lt;p&gt;And another one.&lt;/p&gt;
  &lt;/template&gt;

  &lt;template v-slot:footer&gt;
    &lt;p&gt;Here's some contact info&lt;/p&gt;
  &lt;/template&gt;
&lt;/base-layout&gt;
</code></pre></div><ul><li><p>作用域插槽：目的是让插槽内容能够调用子组件中的数据</p> <div class="language- extra-class"><pre class="language-text"><code>// 子组件CurrentUser，slot上绑定数据
&lt;span&gt;
  &lt;slot v-bind:user=&quot;user&quot;&gt;
    {{ user.lastName }}
  &lt;/slot&gt;
&lt;/span&gt;
// 调用子组件，并通过v-slot获得子组件数据
&lt;current-user&gt;
  &lt;template v-slot:default=&quot;slotProps&quot;&gt; // slotProps名称自定
    {{ slotProps.user.firstName }}
  &lt;/template&gt;
&lt;/current-user&gt;
</code></pre></div></li> <li><p>动态插槽名(利用了 <code>动态指令参数</code>)</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;base-layout&gt;
  &lt;template v-slot:[dynamicSlotName]&gt;
    ...
  &lt;/template&gt;
&lt;/base-layout&gt;
</code></pre></div></li> <li><p>具名插槽指令 <code>v-solt:</code> 可以简写为 <code>#</code></p></li></ul> <hr> <h2 id="动态组件"><a href="#动态组件" class="header-anchor">#</a> 动态组件</h2> <ul><li>使用
在需要处理组件切换的场景，可以使用动态组件。动态组件不是一种组件，而是一种切换组件的实现方式。通过<code>&lt;component&gt;</code>元素加一个特殊的<code>is</code>特性来实现:</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;!-- 组件会在 `currentTabComponent` 改变时改变，currentTabComponent为已注册组件的名字，或一个组件的选项对象 --&gt;
&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;
</code></pre></div><ul><li>避免切换时重渲染导致的性能问题</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;!-- 失活的组件将会被缓存！失活组件的操作结果也会被保存 --&gt;
&lt;keep-alive&gt;
  &lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;
&lt;/keep-alive&gt;
</code></pre></div><p>注：<code>&lt;keep-alive&gt;</code> 要求被切换到的组件都有自己的名字，因为它是通过名字去缓存组件的。</p> <hr> <h2 id="依赖注入"><a href="#依赖注入" class="header-anchor">#</a> 依赖注入</h2> <p>实例选项<code>provide</code>用来指定想要提供给后代组件的数据/方法</p> <div class="language- extra-class"><pre><code>provide: function() {
  return {
    name: 'jerry',
    getAge: this.getAge
  }
}
</code></pre></div><p>实例选项<code>inject</code>用来指定想要从祖先组件接收的数据/方法</p> <div class="language- extra-class"><pre><code>inject: ['name', 'getAge']
</code></pre></div><hr> <h2 id="自定义指令"><a href="#自定义指令" class="header-anchor">#</a> 自定义指令</h2> <div class="language- extra-class"><pre class="language-text"><code>new Vue({
  ...
  directives: {
    // 自定义指令 `v-focus`
    focus: {
      // 钩子函数
      bind() {}, // 指令第一次绑定到元素时调用
      inserted() {}, // 被绑定元素插入父节点时调用
      update() {}, // 所在组件的 VNode 更新时调用
      componentUpdated() {}, // 指令所在组件的 VNode 及其子 VNode 全部更新后调用
      unbind() {} // 指令与元素解绑时调用
    }
  }
})
</code></pre></div><hr> <h2 id="过滤器"><a href="#过滤器" class="header-anchor">#</a> 过滤器</h2> <blockquote><p>Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 (后者从 2.1.0+ 开始支持)。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示：</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>&lt;!-- 在双花括号中 --&gt;
{{ message | capitalize }}

&lt;!-- 在 `v-bind` 中 --&gt;
&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;
</code></pre></div><p>可以在组件中定义局部过滤器：</p> <div class="language- extra-class"><pre class="language-text"><code>new Vue({
  ...
  filters: {
    // 定义一个将字符串首字母改为大写的过滤器
    capitalize: function (value) {
      if (!value) return ''
      value = value.toString()
      return value.charAt(0).toUpperCase() + value.slice(1)
    }
  }
})
</code></pre></div><p>或者在创建 Vue 实例之前全局定义过滤器：</p> <div class="language- extra-class"><pre class="language-text"><code>Vue.filter('capitalize', function (value) {
  if (!value) return ''
  value = value.toString()
  return value.charAt(0).toUpperCase() + value.slice(1)
})

new Vue({
  // ...
})
</code></pre></div><hr> <h2 id="如何看待关注点分离-如何看待vue的单文件组件"><a href="#如何看待关注点分离-如何看待vue的单文件组件" class="header-anchor">#</a> 如何看待关注点分离(如何看待Vue的单文件组件)？</h2> <p>对于组件化开发，抽离出公共模块(组件、js、css等)，然后将强相关的模板、逻辑和样式以内部耦合的形式写在一个组件文件中，相比于从项目层面分离成三个层次并相互调用，单文件组件更加内聚且更易维护。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后更新时间:</span> <span class="time">6/3/2021, 8:02:18 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/docs/technology/1. 前端/1.8 框架/vue-作用域插槽.html" class="prev">
        vue-作用域插槽
      </a></span> <span class="next"><a href="/docs/technology/1. 前端/1.8 框架/vue-慕课网实战 - 去哪儿网学习纪要.html">
        vue-慕课网实战 - 去哪儿网学习纪要
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/docs/assets/js/app.574fc7ba.js" defer></script><script src="/docs/assets/js/2.438c9cc2.js" defer></script><script src="/docs/assets/js/66.313ff872.js" defer></script>
  </body>
</html>
