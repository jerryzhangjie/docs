## 什么是`HTTP`
   > `HTTP`（HyperText Transfer Protocol，超文本传输协议）是建立在 `TCP/IP` 之上的应用层通信协议，它是 `TCP/IP` 协议族的一个子集。 —— `WebSocket` 协议也是如此。

## 因特网分层模型      

   五层模型：
   
   (由下至上，从系统结构的角度)

   | 层级 | 作用 | 包含常见协议
   |--------|--------|--------
   | 物理层 | 规定网路物理介质（双绞线、电磁波等）的电气特性，作用是传送0和1的电信号(比特流) | 
   | 数据链路层 | 确定0和1的分组方式(将电信号封装成帧) | 以太网协议、MAC地址、ARP协议
   | 网络层 | 建立主机到主机的通信，IP寻址 | IP协议(1.为每台计算机分配IP地址；2.确定是否在同一子网络)
   | 传输层 | 建立端口到端口的通信 | TCP（传输控制协议，三次握手、四次挥手）、UDP（用户数据报文协议）
   | 应用层 | 规定应用程序的数据格式 | HTTP（超文本传输协议）、WebSocket、FTP（文本传输协议）、DNS（域名系统）

   越下面的层越靠近硬件，越上面的层越靠近用户。

   (由上至下，从用户使用的角度，见[彻底理解从输入URL到页面展现](../../3%20-%20工具与环境/浏览器/彻底理解从输入URL到页面展现.md))   

   OSI七层模型：

   应用层、**表示层**、**会话层**、传输层、网络层、数据链路层、物理层。

   ![tcp-ip-0](https://raw.githubusercontent.com/jerryzhangjie/image-database/master/picgo/tcp-ip-0.jpg)

   `TCP/IP` 协议族是互联网相关的各类协议的总称。     

   利用 `TCP/IP` 协议族进行网络通信时，会按照分层顺序，与对方进行通信。发送端从应用层往下走，接收端则从物理层往上走。        
   以 `HTTP` 为例：
   * 首先作为发送端的客户端在应用层（`HTTP` 协议）发出一个想看某个 `Web` 页面的 `HTTP` 请求。
   * 接着，为了传输方便，在传输层（`TCP` 协议）把从应用层处收到的数据（`HTTP` 请求报文）分割成报文段，并在各个报文段上打上标记序号后转发给网络层。
   * 在网络层（`IP` 协议），增加作为通信目的地的 `MAC` 地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。
   * 接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的 `HTTP` 请求。

   发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。

## 相关协议及与`HTTP`关系

   ![tcp-ip-1](https://raw.githubusercontent.com/jerryzhangjie/image-database/master/picgo/tcp-ip-1.jpg)

   * `DNS`-应用层：在发送端，提供域名到 `IP` 地址之间的解析服务。
   * `HTTP`-应用层：在发送端，生成请求报文；在接收端，解析请求报文。
   * `TCP`-传输层：在发送端，将请求报文分割成报文段，并按顺序添加序号；在接收端，按序号以原来的顺序重组报文。此外，为确保数据正确传输，通过IP和端口号进行寻址，发送前会进行三次握手建立连接，发送后会进行四次挥手断开连接。
   * `IP`-网络层：使用`ARP`协议，根据目标`IP`地址和端口号查到对应的`MAC`地址，并添加到报文上，然后将数据转交给数据链路层。再利用路由选择机制，经过若干次中转，最终将数据传输到目标服务器。


## `HTTP`的特点
   * 无连接，即本次连接都只处理一个请求，请求结束就断开连接。为了实现长连接（或持久连接），http1.1引入了 keep-alive，允许一次 tcp 连接中进行多次http请求。
   * 无状态，即每个请求都是独立的，不保存上次通信的状态。为了实现期望的保持状态功能，http1.1引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了。
   * 支持 C/S 和 B/S 模式。
   * 简单快速。
   * 灵活，支持传输任意类型的数据对象。数据类型由Content-type字段标识。

## 常用请求方法

   ![methods](https://raw.githubusercontent.com/jerryzhangjie/image-database/master/picgo/methods.jpg)

## 常见状态码

   ![status_code](https://raw.githubusercontent.com/jerryzhangjie/image-database/master/picgo/status_code.jpg)

   |状态码 原因|含义
   |--------|--------
   | 200 OK | 请求已成功处理
   | 204 No Content | 请求已成功处理，但无数据返回（比如提交数据，但无需返回数据的场景）
   | 206 Partial Content | 范围请求已成功处理，返回范围内的数据
   | 301 Moved Permanently | 资源永久重定向，浏览器自动跳转到返回的新的地址
   | 302 Found | 资源临时重定向，浏览器自动跳转到返回的新的地址
   | 304 Not Modified | 服务端已经执行了GET，但文件未变化，可使用浏览器缓存
   | 400 Bad Request | 无法理解该请求
   | 401 Unauthorized | 未认证
   | 403 Forbidden | 未授权(特定资源)
   | 404 Not Found | 未找到请求的资源
   | 500 Internal Server Error | 服务器内部错误
   | 501 Not Implemented | 请求方法不被服务器支持
   | 503 Service Unavailable | 服务器不可用

   1. 301(永久重定向) 和 302(临时重定向) 的区别？

      * 定义。301被请求的资源已永久移动到新位置，再次请求时自动使用本请求返回的url。302被请求的资源临时移动到新位置，再次请求时还是以该url发起请求。
      * 缓存。301默认开启缓存，302默认不开启(除非指定Cache-Control或Exprise)。
      * 搜索引擎。301时搜索引擎会认为老url已失效，会爬取新url内容并保存新url。302时搜索引擎会认为老url未失效，会爬取新url内容，但保存老url地址，当收录的指向新url的地址较多时，搜索引擎会认为是恶意处理从而会对该网站降权。
  
   2. 401(未认证) 和 403(未授权) 的区别？
   
      401未认证是服务器针对用户身份的要求，类比注册用户身份。403未授权是指当前身份的用户无权请求特定资源，类比爱奇艺普通用户无权观看vip视频。
   

## HTTPS

#### HTTP 存在的问题：    

   * 内容窃听。采用明文（不加密）通信，内容可能会被窃听。
   * 身份伪装。不验证对方的身份，有可能遭遇身份伪装。
   * 数据完整性。无法验证数据的完整性，报文可能被篡改。

#### 什么是 HTTPS？

   > HTTPS = HTTP + 加密 + 证书 + 完整性保护

   HTTPS 并非是应用层的一种新协议，它是身披 SSL 外壳的 HTTP。只是 HTTP 通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。      

   通常，HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披 SSL 协议这层外壳的 HTTP。     
   在采用 SSL 后，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护这些功能。

#### 默认端口

http - 80、https - 443

#### https通信过程？

**前置条件**：      

a. 网站向证书颁发机构提供公钥，机构用自己的公钥加密网站的公钥，并加上数字签名，生成公钥数字证书提供给网站；     
b. 浏览器中预先内嵌了证书颁发机构的公钥。

1. **TCP三次握手建立连接**     

![Screenshot0720-0939](https://raw.githubusercontent.com/jerryzhangjie/image-database/master/picgo/Screenshot0720-0939.jpg)

2. **SSL通信（非对称加密通信）**     
   * C -> S：发送客户端支持的加密组件列表、SSL版本
   * S -> C：选择一种服务端也支持的加密组件。发送加密组件和公钥数字证书
   * C -> S：通过证书上的数字签名验证服务端身份，同时用浏览器内置的机构公钥解密证书，获得公钥。生成密钥随机数（用于之后的对称加密通信）并用公钥加密该随机数。发送加密后的密钥。
   * S：通过私钥解密加密后的密钥，获得密钥。

3. **开始HTTP通信（对称加密通信）**     
   * C -> S：用密钥对请求加密，发送请求
   * S -> C：用密钥对请求解密，用密钥对响应加密，发送响应
   * C：用密钥对响应解密

4. **TCP四次挥手断开连接**

![20200720093750](https://raw.githubusercontent.com/jerryzhangjie/image-database/master/picgo/20200720093750.jpg)

## URI 与 URL 的区别

   URI 统一资源标识符，可以理解为表示的就是某个资源。而 URL 统一资源定位符，表示的是资源在互联网中的地址。

## cookie、session 与 token 的区别

   Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。    
   Cookie存放在硬盘中。为了获得更高的存取速度，服务器一般把Session放在内存里。    
   Session是服务器端使用的一种记录客户端状态的机制，使用上比Cookie简单一些，相应的也增加了服务器的存储压力。客户端访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是Session。如果说Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。
   cookie中存放的是例如jgbsessid字段，是“客户明细表”中Session的id，有了该id，服务端才能查找对应的Session数据。Session是会话级别的，因此同一机器的两个浏览器窗口访问服务器时，会生成两个不同的Session。      

   * session 是由服务端针对当前会话，生成的一个随机数，通常放在cookie中发送给客户端，并存储在服务器的session列表中。客户端发送请求时cookie中携带session的id。服务器收到 cookie 后解析出 sessionId，再去 session 列表中查找，若能查到则匹配成功。
   * cookie 是由服务端生成，用于传输用户信息，存储在客户端，请求中会自动添加。
   * token 是由服务端根据用户id、用户名、定义好的密钥、过期时间生成的签名令牌，通常存放在客户端的localStroage，请求时手动添加在请求头中，服务器收到 token 后解密就可知道是哪个用户。与session相比，不需要存储在服务端，是用计算性能换取存储空间的方案，服务器的横向扩展性更好。同时，也是CSRF（跨站请求伪造）的解决方案。

   参考 
   [如何区分不同用户——Cookie/Session机制详解](https://www.cnblogs.com/zhouhbing/p/4204132.html)
   [彻底理解cookie，session，token](https://www.cnblogs.com/moyand/p/9047978.html)     
   [彻底弄懂session，cookie，token](https://segmentfault.com/a/1190000017831088)

## http1.0与http1.1区别

   * 缓存方式：1.0 用 Expires、Last-Modified、If-Modified-Since；1.1使用 Cache-Control、Etag、If-None-Match。[详见http缓存机制](https://github.com/jerryzhangjie/Blog/blob/master/Front-end/1%20-%20%E7%90%86%E8%AE%BA%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E7%BD%91%E7%BB%9C/HTTP%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6.md)
   * 请求体优化：HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分
   * 长连接：1.0中每个请求都要进行tcp连接，而1.1中引入长连接（Connection: keep-alive 默认开启，可通过设置nginx或apache服务器实现），建立一个tcp连接通道后，一定时间内可以发送多次http请求。注：长连接实现的是一次连接可发送多个请求，但这个“多个”是串行的，而我们从浏览器network中看到的同域名请求最多同时发送6个http请求，是浏览器开启了多个网络线程（每个线程都建立一个tcp连接）实现的，并非http1.1实现了并行，也就是说第7个请求有可能与第1个请求用的是同一个连接(二者串行关系)，但第1个和第2个很可能是两个不同的连接(分属于两个网络线程)。

## http2与http1.x区别

   http1.1还存在的问题：长连接只是解决了多次连接的问题，并没有真正实现并行传输（虽然浏览器的多线程可并行请求，但是要为每个线程建立一个tcp连接）。

   为了解决上述问题，http2.0引入二进制`数据帧`和二进制`数据流`的概念，实现多路复用。帧负责对数据进行序列标识，以确保接收并行流数据后可按顺序重新组装。流负责数据的并行传输，同一域名下所有请求，不管请求数有多少，都只建立一个tcp连接，然后基于流进行并行传输。

   有了这个特性，之前我们的两个性能优化方式就没有并要了：1. 静态资源合并；2. 多域名提高下载速度。

   区别可概括为：
   1. 二进制格式；
   2. 多路复用；
   3. 头部压缩；
   4. 服务端推送。

   注意：浏览器6个请求限制，是指浏览器在同一个域名下最多开启6个线程，即建立6个tcp连接。而多路复用不受这个限制，可以同时并行请求同一个域名下的所有请求。

## GET 与 POST 区别

GET 和 POST 是 HTTP 的两种请求方式，HTTP 是基于 TCP/IP 的应用层协议，也就是说二者使用的是相同的传输层协议，所以，在传输上二者没有本质区别。
二者的区别主要有以下几点：
1. 报文格式的规范约定。GET 参数应放在 URL 上，而 POST 参数应该放在请求体中。但这只是规范约定，而非 TCP 的要求，所以，只要服务端支持，我们也可以将 GET 参数写在请求体，将 POST 参数写在 URL 上。
2. 参数的大小限制。HTTP协议没有body和url的长度限制，这些限制大多是浏览器和服务器的原因。GET 的 URL 通常被限定在几K范围内。
3. 安全性。Post相较于Get是稍微安全一些的，因为数据在地址栏是不可见的。然后，从传输的角度来说，他们都是不安全的，因为HTTP在网络上都是明文传输的，只要在网络节点上捉包，就能完整的获取数据报文。想要安全的传输，就只有加密，使用HTTPS。
4. 发送数据包次数。有些浏览器会将 POST 的 header 和 body 分开发送，服务端返回100状态码再发送body。但实践发现 Chrome 并非如此。
5. 缓存。大多数浏览器 GET 请求是默认开启缓存的，而 POST 需手动设置。

## POST 与 PUT 区别

* HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。
* POST和PUT的区别容易被简单地误认为“POST表示创建资源，PUT表示更新资源”；而实际上，二者均可用于创建资源，更为本质的差别是在幂等性方面。
* POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：POST http://www.forum.com/articles的语义是在http://www.forum.com/articles下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。而PUT所对应的URI是要创建或更新的资源本身。比如：PUT http://www.forum/articles/4231的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。

## 常见 http 报文解析

![http报文.jpg](https://raw.githubusercontent.com/jerryzhangjie/image-database/master/picgo/http%E6%8A%A5%E6%96%87.jpg)


*参考*：

* http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html
* 